<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 3 页 | NG's Blog</title>
  <meta name="author" content="NG">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="NG's Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="NG's Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">NG's Blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-10-08T02:02:18.000Z"><a href="/2013/10/08/2013-05-14-2/">10月 8 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/10/08/2013-05-14-2/">第二代身份证 - 是否在愚弄公民?</a></h1>
  

    </header>
    <div class="entry">
      
        <p>本人半个多月前发贴：[让中国人愤怒的第二代身份证] 幸得各位网友支持，成为论坛热帖。在此一并感谢。<br>此帖作为前帖的补充和总结，并提出新的论据，对第二代身份证相关的技术、经济和法律问题提出合理的质疑。<br>  引言<br>  第二代身份证究竟有何“优越”之处，以下是一篇有代表性的公开报道：<br>  （为了方便分析对照，下文中段落编号是笔者加上的。）<br>  1。中国第二代身份证是由公安部和信息产业部联合负责操作，属于非接触式IC卡，具有视读和机读两种功能，<br>总体分为硬件和软件两大系统，关键技术皆由公安机关指定的定点资格企业负责生产。<br>  2。第二代身份证中集成了一块专用芯片，居民的上述信息不仅仅被印在了卡片的表面，更是被直接“刻”进了卡片的心脏地带。通过这块芯片，第二代身份证可以与阅读身份证的机器进行相互认证，通过机读信息进行安全性确认；<br>  3。同时由于采用了这种芯片技术，第二代身份证的信息存储和证件查询具备了数据库技术和网络技术，因此也就可以实现全国范围内的联网快速查询和身份识别，大大提高了查询和识别的速度，并实现了信息共享。<br>  4。除此以外，由于第二代身份证的芯片预留了大量存储空间，随着社会发展的需要，公安机关还可以根据未来的需要录入更多的资料。未来的身份证会变得越来越智能，一张“居民身份证”就可以为多种社会服务提供身份识别的支持，方便大家的使用。<br>  5。目前在我国，今后市民在迁移户籍时将不再需要更换身份证，公安机关只要将相关内容写入芯片中就行了。至于今后我国身份证中还将记录怎样的信息，还需要依照相关的法律来具体确定。<br>  6。当然，要保证身份识别的安全性，仅仅靠现有的技术还是不够的。未来我们的身份证除了记录居民的个人基本资料之外，还将把诸如指纹信息、虹膜特征等生物特征信息一并记录下来。研究人员已开展了用于身份鉴别的人脸识别、话音识别、联机签名识别、指纹识别等多项研究工作，并取得了一定成效。<br>  7。第二代居民身份证引发巨大商机<br>  如果一张IC卡身份证按20元计，预计到2010年如期更换IC卡身份证规模达70%，届时将换发约8亿张IC卡身份证，市场规模就是160亿元。而且一旦IC卡身份证推行开来，将带动各种公共场所的终端需求。</p>
<pre><code>                                                    <span class="literal">-</span><span class="literal">-</span> <span class="comment">2004</span>-<span class="comment">08</span>-<span class="comment">26</span> <span class="comment">新闻晨报</span>  </code></pre>
<p>  一、第二代身份证在技术、经济方面的硬伤</p>
<p>  说其硬伤，就从上面第2点开始，既然身份证芯片记录了公民个人信息，那么先提一个问题：已经领了二代身份证的读者，你们有谁知道自己的身份证芯片中存储了什么信息？<br>  答案是否定的，作为公民个人，我们现在只能从表面看到，而根本无法得知身份证芯片中真正写了什么信息。<br>  这就是说，我们目前必须接受一个与自己密切有关而又不可知的东西。<br>  但是，将来不仅是执法部门，就连银行、宾馆等商业部门也可以允许读取、验证我们个人的信息。自己的信息却掌握在别人的手里，这又如何体现公民的隐私权？<br>  这个问题之所以被轻视，有过去顽固的习惯势力影响。多年以来，个人的人事档案就是对本人保密的，但在很多时候却决定一个人的人生命运。这种“传统”一直延续到身份证问题上。<br>  从技术上来体现这点似乎并不难，只要安装足够的读取身份证卡信息的设备，给每个公民提供验证信息机会就可以了。<br>  但这点在目前是做不到的，未来几年内也很难做到。做不到主要是因为经济上的原因。<br>  最早试行二代身份证的地区，已经将近两年，也没有普遍推广读卡机具。这是为何呢？<br>  请看上文第1条：关键技术皆由公安机关指定。。。<br>  身份证的关键技术，的确掌握在政府有关部门手中。但由于现今“产业垄断化”的潮流，这种关键技术实际上是通过政府部门下属“产业化”公司经营、有偿转让给使用者的。<br>  根据公开的市场信息，关键技术出让价格让许多有意参加身份证卡机具制作的企业望而却步。<br>  而接受了技术转让的企业，则进一步将此费用摊入产品成本，从而使生产的专用读卡机具市场价格高得惊人。<br>  于是地方公安部门便以价格太高为由，拒绝购买。当然他们有一个理由：既然是上面指定发放二代证，那么应该也由上面发放读卡机具。<br>  但市场上还是有人对此读卡机具感兴趣，主要是银行或一些新型服务企业。他们只是从商业角度考虑。<br>  这就不可避免地带来一个后果：将来二代身份证的用处，更多地体现在公民信息被出卖给商业部门利用！（见上文第7点）</p>
<p>  此问题将来如何解决？因为它是一个硬伤，所以实在没有好的办法解决。<br>  从办证费用来看，每个身份证至少20元（大多数地区加收超过20），但这20元，基本不可能用于读卡机具购买。已经有解释，这20元是全部用于身份证制作成本，不仅是卡商品成本，也包括其中的制作人工费。这种制作人工费是外请打工人员发生的。<br>  其实作为一项信息工程，费用还远不于此。除了机具外，还必须在背后建立联网的信息系统。（见上文第3点）。<br>  这就是说，除了20元或不止20元，国家还必须拨出一大笔财政款（由纳税人负担），来解决这个问题。<br>  这种款项预算将是十分巨大的。即使能够拨出，也要等多年以后。或许就此不了了之也有可能。</p>
<p>  也就是说，公民支出了费用，国家又化了大量人力、物力。<br>  而我们每个人手中得到的二代身份证，在今后相当长的年份里，只能当一张塑料卡片使用！<br>  与第一代身份证相比，它防伪功能要好，其它并没有多大差别。甚至在处理姓名的问题上，还不如第一代证用手写解决！<br>  读者中如果有谁还办过其它IC卡证件，就能体会到这种情况是必然会发生的。过去曾经有过多少个办IC卡证件而实际上无用的例子？！<br>  再说另一个技术上的硬伤：二代身份证的优越性，很大程度上是由其内部芯片储存信息来提供的。<br>  这种内部芯片“优越”的一个主要体现，就是内部信息可以改写，这在居民迁移户籍改写信息有用。（见上文第5点）<br>  但居民迁移户籍，居住地址肯定是要改的。尽管内部可以改写，而身份证表面却是无法改写的！<br>  身份证表面怎能不改？ 到时候怎么办？ 再让居民重办身份证？ 还是就此糊涂了之？<br>  因为身份证表面不能改写，就基本在目前否定了内部芯片的优越性。<br>  那么，又为何要设计这种内部芯片？ 它不仅是多余的问题，更主要的是因为这个芯片，造成读卡机具成本高昂。<br>  世界上怎能有如此不理性的技术经济分析和决策？<br>  二、第二代身份证在技术、经济、法律方面的软伤</p>
<p>  A。姓名权问题<br>  计算机难以处理中文冷僻字，最初是由于规划不周造成，现在则进一步延伸到身份证问题上。<br>  最早使用的GB2312-80国家标准，只能处理6000多个汉字。显然是一个很不重视中国文化的结果。<br>  把这个归咎于当时技术发展是推脱责任的，因为它主要是标准问题。而同期台湾BIG5系统却能处理13000多个汉字。<br>  而现在中文WINDOWS系统下，一般用的是GBK汉字库，它能处理两万多个汉字。令人啼笑皆非的是，GBK并不是真正的国家标准，只是为了应付中文信息处理急剧发展而临时定的规范。<br>  两万多个汉字不能解决冷僻字问题，所以公安部与有关部门研制开发了GB13000新字库，有3万多个汉字。但仍然无法完全解决冷僻字问题。<br>  未来的国家汉字信息标准将与国际标准CJK（中日韩）协同一致，总共含7万多个汉字。但要彻底解决冷僻字问题，必须首先要澄清一个问题：汉字个数最多究竟有多少？<br>  有一种说法是10万多个，但至今无法确切肯定。<br>  其实这预示了，二代身份证不能完善保证公民法律上的姓名权。<br>  对这个问题最好是不要遮掩，而是放开让全民讨论。<br>  但让公民什么都知情，似乎又不是我们的习惯做法。<br>  所以将来还会产生争议。<br>  B。安全性问题<br>  在报道文章第6条中说明：当然，要保证身份识别的安全性，仅仅靠现有的技术还是不够的。<br>  这是实事求是的说法。<br>  另有一种说法，认为伪造身份证比伪造钞票还难。<br>  其实这两者是不可比的。<br>  首先，二代身份证仍然属于非接触式IC卡（见上文第1条），虽然有我们自己的规范，但技术框架是建立在国际标准基础上的。<br>  现今中国掌握IC卡技术的厂家和人员比造钞票的要多得多。<br>  其次，要推广二代身份证应用，就必须引入更多的单位参与，并将部分技术秘密转给他们。<br>  应用越广，信息泄密的危险性也越大。这是一个两难抉择：要么更多方便，更少安全。要么相反。<br>  再者，IC卡相关技术还在发展，未来会进展到哪一步，还很难预料。<br>  那么如何应对这个问题？ 是否能象报道文章第6条所说，进一步引进更新的技术？用DNA识别技术？<br>  这会带来另外的弊端，一是公民失去更多的隐私，二是承担更大的负担。<br>  当然，这个问题还是不确定的，所以将其归为软伤。<br>  C。公民经济权益问题<br>  从以上种种情况看，二代身份证应用条件在中国并没有成熟。既然没有成熟，即是一个试验。<br>  那么，这样的试验直接向公民收费是否合适？<br>  但这点似乎没有多少讨论的机会。公用事业不断涨价的例子已经告诉我们，这类事情我们往往是无可奈何的。<br>  乱办证、乱收费最初都是由经济利益驱动而导致的。因为政府部门要养着一批人，要吃饭。<br>  第二代身份证最初的方案，便是由国家垄断生产。这个方案由于人大反对，而后来更改为向社会招标。</p>
<p>  D。公民隐私权问题<br>  这虽然只是一个潜在的问题，但按现代文明社会的标准，却是一个极其重要的问题。<br>  中国传统体制历来不重视人的隐私权，甚至于在文革中发展到“斗私批修”，要人自己把隐私揭露出来。是反人性的。<br>  其实，自由在很大程度上取于人的隐私权有多少。隐私权是现代人权最重要的部分之一。<br>  如前面报道，第二代身份证设计原义是在内包含更多的个人信息，如指纹信息、虹膜特征等生物特征。而身份证内含芯片现在的利用率，按常规估计不会到十分之一，其余空间可以预留给将来使用。<br>  我们能对这种潜在的侵权无动于衷吗？<br>  客观地说，隐私权也不是绝对不可放弃。例如在单位工作，工作时间原则上不应处理私事。<br>  于是打工者以放弃隐私为代价，换来了维持生存的收入。<br>  所以放弃隐私应该建立在自愿的原则基础上，同时应该获得必要的回报。<br>  但在未来身份证问题上，能保证我们有这样的选择吗？<br>  为此可以问一个问题，读者中有几个人知道，我们的身份证法是什么时候颁布的？ 里面又规定了什么具体内容？<br>  我想大多数人是不知道的。<br>  既然如此，将来隐私权的处理和规定情况会怎么变化，与你也不会有多大关系。<br>  这就是我们的现状。<br>  三、我们应当如何面对第二代身份证？</p>
<p>  面对第二代身份证将采取何种行动？我想不需要提出什么建议。每个成熟的公民自会作出自己合理的判断和选择。<br>  但实际上，目前不申领第二代身份证并不违反法律，持有第一代身份证仍然合法。<br>  如果我有机会，将对有关部门郑重提出如下建议：<br>  1。第二代身份证让公民采取自愿原则申领。<br>  2。无限期推迟第一代身份证停用时间。<br>  3。由于技术原因（例如由于迁户口改身份证，或IC卡技术原因）造成补领身份证，应该由行政机关承担费用。<br>  4。未来所有关于身份证变动的问题，应当先交由公民广泛讨论后再作决定。</p>
<h2>  这不仅是表达公民应有的权益，也是为了政府部门将来的工作着想。  </h2>
<p>  本帖初创于[猫眼看人]，转帖时请注明出处。<br>[参考资料]<br>A.中华人民共和国居民身份证法<br>B.新华网: 公安部通报换发第二代居民身份证有关情况<br>C.人民网>>专家文章: 中国第三代身份证将带指纹等生物识别特征<br>D.RFID(无线射频技术)世界网: 多篇有关第二代身份证的专业文章</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-10-08T02:02:18.000Z"><a href="/2013/10/08/2013-07-01-14/">10月 8 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/10/08/2013-07-01-14/">ISO8583协议-银行交易标准</a></h1>
  

    </header>
    <div class="entry">
      
        <p>ISO8583包（简称8583包）是一个国际标准的包格式，最多由128个字段域组成，每个域都有统一的规定，并有定长与变长之分。<br>      8583包前面一段为位图，用来确定包的字段域组成情况。<br>      其中位图是8583包的灵魂，它是打包解包确定字段域的关键， 而了解每个字段域的属性则是填写数据的基础。  </p>
<p>1、 位图描述如下：<br>位图位置：1<br>格式：定长<br>类型：B16（二进制16位，16*8=128bit）<br>描述：<br>    如将位图的第一位设为‘1’，表示使用扩展位图（128个域），否则表示只使用基本位图（64个域）。<br>    如使用某数据域，应在位图中将相应的位设位‘1’，如使用41域，需将位图的41位设为‘1’。<br>选用条件：如使用65到128域，需设位图域第一位为‘1’  </p>
<p>2、每个域的定义如下：<br>typedef struct ISO8583<br>{<br>     int bit_flag; /*域数据类型0 — string, 1 — int, 2 — binary*/<br>     char *data_name; /*域名*/<br>     int length; /*数据域长度*/<br>     int length_in_byte;/*实际长度（如果是变长）*/<br>     int variable_flag; /*是否变长标志0：否 2：2位变长, 3：3位变长*/<br>     int datatyp; /*0 — string, 1 — int, 2 — binary*/<br>     char *data; /*存放具体值*/<br>     int attribute; /*保留*/<br>} ISO8583;</p>
<p>ISO8583 Tbl8583[128] =<br>{<br>/* FLD 1 */ {0,“BIT MAP,EXTENDED ”, 8, 0, 0, 2, NULL,0},<br>/* FLD 2 */ {0,“PRIMARY ACCOUNT NUMBER ”, 22, 0, 2, 0, NULL,0},<br>/* FLD 3 */ {0,“PROCESSING CODE ”, 6, 0, 0, 0, NULL,0},<br>/* FLD 4 */ {0,“AMOUNT, TRANSACTION ”, 12, 0, 0, 1, NULL,0},<br>/* FLD 5 */ {0,“NO USE ”, 12, 0, 0, 0, NULL,0},<br>/* FLD 6 */ {0,“NO USE ”, 12, 0, 0, 0, NULL,0},<br>/* FLD 7 */ {0,“TRANSACTION DATE AND TIME ”, 10, 0, 0, 0, NULL,0},<br>/* FLD 8 */ {0,“NO USE ”, 8, 0, 0, 0, NULL,0},<br>/* FLD 9 */ {0,“NO USE ”, 8, 0, 0, 0, NULL,0},<br>/* FLD 10 */ {0,“NO USE ”, 8, 0, 0, 0, NULL,0},<br>/* FLD 11 */ {0,“SYSTEM TRACE AUDIT NUMBER ”, 6, 0, 0, 1, NULL,0},<br>/* FLD 12 */ {0,“TIME, LOCAL TRANSACTION ”, 6, 0, 0, 0, NULL,0},<br>/* FLD 13 */ {0,“DATE, LOCAL TRANSACTION ”, 4, 0, 0, 0, NULL,0},<br>/* FLD 14 */ {0,“DATE, EXPIRATION ”, 4, 0, 0, 0, NULL,0},<br>/* FLD 15 */ {0,“DATE, SETTLEMENT ”, 4, 0, 0, 0, NULL,0},<br>/* FLD 16 */ {0,“NO USE ”, 4, 0, 0, 0, NULL,0},<br>/* FLD 17 */ {0,“DATE, CAPTURE ”, 4, 0, 0, 0, NULL,0},<br>/* FLD 18 */ {0,“MERCHANT&#39;S TYPE ”, 4, 0, 0, 0, NULL,0},<br>/* FLD 19 */ {0,“NO USE ”, 3, 0, 0, 0, NULL,0},<br>/* FLD 20 */ {0,“NO USE ”, 3, 0, 0, 0, NULL,0},<br>/* FLD 21 */ {0,“NO USE ”, 3, 0, 0, 0, NULL,0},<br>/* FLD 22 */ {0,“POINT OF SERVICE ENTRY MODE ”, 3, 0, 0, 0, NULL,0},<br>/* FLD 23 */ {0,“NO USE ”, 3, 0, 0, 0, NULL,0},<br>/* FLD 24 */ {0,“NO USE ”, 3, 0, 0, 0, NULL,0},<br>/* FLD 25 */ {0,“POINT OF SERVICE CONDITION CODE ”, 2, 0, 0, 0, NULL,0},<br>/* FLD 26 */ {0,“NO USE ”, 2, 0, 0, 0, NULL,0},<br>/* FLD 27 */ {0,“NO USE ”, 1, 0, 0, 0, NULL,0},<br>/* FLD 28 */ {0,“field27 ”, 6, 0, 0, 0, NULL,0},<br>/* FLD 29 */ {0,“NO USE ”, 8, 0, 1, 0, NULL,0},<br>/* FLD 30 */ {0,“NO USE ”, 8, 0, 1, 0, NULL,0},<br>/* FLD 31 */ {0,“NO USE ”, 8, 0, 1, 0, NULL,0},<br>/* FLD 32 */ {0,“ACQUIRER INSTITUTION ID. CODE ”, 11, 0, 2, 0, NULL,0},<br>/* FLD 33 */ {0,“FORWARDING INSTITUTION ID. CODE ”, 11, 0, 2, 0, NULL,0},<br>/* FLD 34 */ {0,“NO USE ”, 28, 0, 2, 0, NULL,0},<br>/* FLD 35 */ {0,“TRACK 2 DATA ”, 37, 0, 2, 0, NULL,0},<br>/* FLD 36 */ {0,“TRACK 3 DATA ”,104, 0, 3, 0, NULL,0},<br>/* FLD 37 */ {0,“RETRIEVAL REFERENCE NUMBER ”, 12, 0, 0, 0, NULL,0},<br>/* FLD 38 */ {0,“AUTH. IDENTIFICATION RESPONSE ”, 6, 0, 0, 0, NULL,0},<br>/* FLD 39 */ {0,“RESPONSE CODE ”, 2, 0, 0, 0, NULL,0},<br>/* FLD 40 */ {0,“NO USE ”, 3, 0, 0, 0, NULL,0},<br>/* FLD 41 */ {0,“CARD ACCEPTOR TERMINAL ID. ”, 8, 0, 0, 0, NULL,0},<br>/* FLD 42 */ {0,“CARD ACCEPTOR IDENTIFICATION CODE ”, 15, 0, 0, 0, NULL,0},<br>/* FLD 43 */ {0,“CARD ACCEPTOR NAME LOCATION ”, 40, 0, 0, 0, NULL,0},<br>/* FLD 44 */ {0,“ADDITIONAL RESPONSE DATA ”, 25, 0, 2, 0, NULL,0},<br>/* FLD 45 */ {0,“NO USE ”, 76, 0, 2, 0, NULL,0},<br>/* FLD 46 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 47 */ {0,“field47 ”,999, 0, 3, 0, NULL,0},<br>/* FLD 48 */ {0,“ADDITIONAL DATA —- PRIVATE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 49 */ {0,“CURRENCY CODE,TRANSACTION ”, 3, 0, 0, 0, NULL,0},<br>/* FLD 50 */ {0,“CURRENCY CODE,SETTLEMENT ”, 3, 0, 0, 0, NULL,0},<br>/* FLD 51 */ {0,“NO USE ”, 3, 0, 0, 0, NULL,0},<br>/* FLD 52 */ {0,“PERSONAL IDENTIFICATION NUMBER DATA ”, 8, 0, 0, 2, NULL,0},<br>/* FLD 53 */ {0,“SECURITY RELATED CONTROL INformATION”, 16, 0, 0, 0, NULL,0},<br>/* FLD 54 */ {0,“ADDITIONAL AMOUNTS ”,120, 0, 3, 0, NULL,0},<br>/* FLD 55 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 56 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 57 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 58 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 59 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 60 */ {0,“NO USE ”, 5, 0, 3, 0, NULL,0},<br>/* FLD 61 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 62 */ {0,“NO USE ”, 11, 0, 3, 0, NULL,0},<br>/* FLD 63 */ {0,“NO USE ”, 11, 0, 3, 0, NULL,0},<br>/* FLD 64 */ {0,“MESSAGE AUTHENTICATION CODE FIELD ”, 8, 0, 0, 2, NULL,0},<br>/* FLD 65 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 66 */ {0,“NO USE ”, 1, 0, 0, 0, NULL,0},<br>/* FLD 67 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 68 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 69 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 70 */ {0,“SYSTEM MANAGEMENT INformATION CODE ”, 3, 0, 0, 0, NULL,0},<br>/* FLD 71 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 72 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 73 */ {0,“NO USE ”, 6, 0, 0, 0, NULL,0},<br>/* FLD 74 */ {0,“NUMBER OF CREDITS ”, 10, 0, 0, 0, NULL,0},<br>/* FLD 75 */ {0,“REVERSAL NUMBER OF CREDITS ”, 10, 0, 0, 0, NULL,0},<br>/* FLD 76 */ {0,“NUMBER OF DEBITS ”, 10, 0, 0, 0, NULL,0},<br>/* FLD 77 */ {0,“REVERSAL NUMBER OF DEBITS ”, 10, 0, 0, 0, NULL,0},<br>/* FLD 78 */ {0,“NUMBER OF TRANSFER ”, 10, 0, 0, 0, NULL,0},<br>/* FLD 79 */ {0,“REVERSAL NUMBER OF TRANSFER ”, 10, 0, 0, 0, NULL,0},<br>/* FLD 80 */ {0,“NUMBER OF INQUIRS ”, 10, 0, 0, 0, NULL,0},<br>/* FLD 81 */ {0,“AUTHORIZATION NUMBER ”, 10, 0, 0, 0, NULL,0},<br>/* FLD 82 */ {0,“NO USE ”, 12, 0, 0, 0, NULL,0},<br>/* FLD 83 */ {0,“CREDITS,TRANSCATION FEEAMOUNT ”, 12, 0, 0, 0, NULL,0},<br>/* FLD 84 */ {0,“NO USE ”, 12, 0, 0, 0, NULL,0},<br>/* FLD 85 */ {0,“DEBITS,TRANSCATION FEEAMOUNT ”, 12, 0, 0, 0, NULL,0},<br>/* FLD 86 */ {0,“AMOUNT OF CREDITS ”, 16, 0, 0, 0, NULL,0},<br>/* FLD 87 */ {0,“REVERSAL AMOUNT OF CREDITS ”, 16, 0, 0, 0, NULL,0},<br>/* FLD 88 */ {0,“AMOUNT OF DEBITS ”, 16, 0, 0, 0, NULL,0},<br>/* FLD 89 */ {0,“REVERSAL AMOUNT OF DEBITS ”, 16, 0, 0, 0, NULL,0},<br>/* FLD 90 */ {0,“ORIGINAL DATA ELEMENTS ”, 42, 0, 0, 0, NULL,0},<br>/* FLD 91 */ {0,“FILE UPDATE CODE ”, 1, 0, 0, 0, NULL,0},<br>/* FLD 92 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 93 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 94 */ {0,“SERVICE INDICATOR ”, 7, 0, 0, 0, NULL,0},<br>/* FLD 95 */ {0,“REPLACEMENT AMOUNTS ”, 42, 0, 0, 0, NULL,0},<br>/* FLD 96 */ {0,“NO USE ”, 8, 0, 0, 0, NULL,0},<br>/* FLD 97 */ {0,“AMOUNT OF NET SETTLEMENT ”, 16, 0, 0, 0, NULL,0},<br>/* FLD 98 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 99 */ {0,“SETTLEMENT INSTITUTION ID ”, 11, 0, 2, 0, NULL,0},<br>/* FLD 100 */ {0,“RECVEING INSTITUTION ID ”, 11, 0, 2, 0, NULL,0},<br>/* FLD 101 */ {0,“FILENAME ”, 17, 0, 2, 0, NULL,0},<br>/* FLD 102 */ {0,“ACCOUNT IDENTIFICATION1 ”, 28, 0, 2, 0, NULL,0},<br>/* FLD 103 */ {0,“ACCOUNT IDENTIFICATION2 ”, 28, 0, 2, 0, NULL,0},<br>/* FLD 104 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 105 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 106 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 107 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 108 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 109 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 110 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 111 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 112 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 113 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 114 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 115 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 116 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 117 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 118 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 119 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 120 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 121 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 122 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 123 */ {0,“NEW PIN DATA ”, 8, 0, 3, 2, NULL,0},<br>/* FLD 124 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 125 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 126 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 127 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 128 */ {0,“MESSAGE AUTHENTICATION CODE FIELD ”, 8, 0, 0, 2, NULL,0},<br>}; </p>
<p>３、变长，定长域说明<br>如第二域：域名为主帐号，<br>数据类型为string<br>长度为22（是长长度不得超过此数）<br>是个２位变长域<br>由于是２位变长，在打包时需在数据域前加上数据的实际长度，如为１９位，则表示为：<br>１９＋数据值（即前两位为长度）<br>如第三域：域名为处理码，<br>数据类型为string<br>长度为６<br>是个定长域<br>必须填满６位。  </p>
<p>附A:ISO8583各域段的说明<br>1，信息类型（message type）定义<br>位图位置：－<br>格式：定长<br>类型：N4<br>描述：<br>数据包的第一部分，定义数据包的类型。<br>数据类型由数据包的发起者设定，应遵循以下要求：<br>数据包开始部分必须是信息类型；<br>对不支持的信息类型能给出拒绝应答。<br>0100授权交易<br>0110授权交易答复<br>0200金融交易<br>0210金融交易答复<br>0240查询交易<br>0250查询交易答复<br>0400冲正交易<br>0410冲正交易答复<br>0800管理交易<br>0810管理交易答复<br>2，位图(Bit Map) - 基本位图和扩展位图<br>位图位置：1<br>格式：定长<br>类型：B16<br>描述：<br>如将位图的第一位设为‘1’，表示使用扩展位图，否则表示只使用基本位图。<br>如使用某数据域，应在位图中将相应的位设位‘1’，如使用41域，需将位图的41位设为‘1’。<br>选用条件：如使用65到128域，需设位图域为‘1’<br>3、Bit02主帐号(Primary Account Number)</p>
<p>位图位置：02<br>格式：变长,LLVAR<br>类型：N..22<br>描述：<br>唯一的确认一个用户交易的基本帐号。<br>由于银行电子服务系统涉及多个应用系统，而帐号长度最多为22位，故将原标准的19长度改为22位。<br>4、Bit03 处理代码 （Processing Code）<br>位图位置：03<br>格式：定长<br>类型：N6<br>描述：用于描述交易对客户帐户造成何种影响的代码。<br>处理代码和信息码一起可唯一定义一种交易的类型。<br>处理代码由以下三部分组成：<br>位置描述<br>1－2交易动作码<br>3－4付出帐户类型，用于借记类，如查询、代收费、转场交易。<br>5－6收入帐户类型，用于代收费、转帐等。<br>其中：<br>ff : 付出帐户<br>tt： 收入帐户<br>* 视主机而定<br>5，Bit04 交易金额 （Amount, Transaction）<br>位图位置：04<br>格式：定长<br>类型：N12<br>描述：帐户人要求交易的交易金额，不含任何处理和交易费用。<br>金额的表示和货币代码有关，应能表示相应货币的最小单位。参ISO4217有关货币代码定义。<br>如“000000000100”用于表示美元，表示1.00元；如用于表示意大利货币，则表示100里拉。<br>对于查询等交易，应设交易金额为“000000000000”。<br>6，Bit06交易日期和时间（Transmission Date and Time）<br>位图位置：07<br>格式：定长，MMDDhhmmss<br>类型：N10<br>描述：本地交易日期和时间<br>7，Bit11系统跟踪号（Systems Trace Audit Number)<br>位图位置：11<br>格式：定长<br>类型：N6<br>描述：终端交易的跟踪号码。<br>交易发起终端填写，和“交易日期、时间”、信息类型等合在一起可唯一定义某一个终端的唯一一笔交易。即是说，在同一天，对一终端，同一类交易的系统跟踪号应保证不同。系统跟踪号在交易过程中不能修改。使用此域来匹配请求和通知类交易的返回。<br>应用系统使用此域来检查收到的授权、金融、自动冲正、结算、管理和网管等类交易的应答包是否是其请求包的应答。<br>系统跟踪号不用于匹配自动冲正交易，也不用于在预授权消费时匹配前面的预授权交易。参90域。<br>对于银行电子服务系统，其系统跟踪号是交易流水号。<br>8，Bit12本地交易时间（Time ,Local Transaction）<br>位图位置：12<br>格式：定长，hhmmss<br>类型：N6<br>描述：交易在终端上发生的时间。<br>本地交易时间在交易处理过程中不能改变。在自动冲正，存贮转发时，本地交易时间不能改变。<br>9，Bit13本地交易日期(Date ,Local Transaction)<br>位图位置：13<br>格式：定长,MMDD<br>类型：N4<br>描述：交易在终端上发生的时间。<br>本地交易时间不能改变，在自动冲正、存储转发交易时，本地交易时间也不能改变。<br>10，Bit14有效期(Date ,Expiration)<br>位图位置：14<br>格式：定长,YYMM<br>类型：N4<br>描述：卡的有效期，年年月月<br>由于卡类写磁格式不同，收单行可能提不出卡的有效期，授权机构从卡的二磁道中提取卡的有效期。如卡无二磁道，收单行应要求手工录入卡的有效期。<br>选用条件：100、200、400等交易如没有2、3磁道时，一定要有此域。<br>11，Bit15结算日期(Date ,Settlement)<br>位图位置：15<br>格式：定长，MMDD<br>类型：N4<br>描述：<br>银行电子服务系统和主机结算的时间，格式月月日日。<br>结帐日期前发生的交易参加当天结算。<br>在结算时，结帐日期也用于计算处理、交易费用。<br>12，Bit17获取日期(Date ,Capture)<br>位图位置：17<br>格式：定长，MMDD<br>类型：N4<br>描述：从主机获取交易的记帐日期。通常用于主机和商户清算。<br>13，Bit18商户类型（Merchant&#39;s Type）<br>位图位置：18<br>格式：定长<br>类型：N4<br>描述：定义商户产品和服务类型的代码<br>商户类型用于金融、授权交易，用于指定服务点的类型。它主要有以下用途：<br>决定预授权交易得到确认的最长时间；<br>控制合法限额；<br>为交易授权处理，控制网络操作规则；<br>欺诈检测；<br>用于商户分类报表；<br>交易费用处理。<br>根据ISO8583标准，应使用相应的国家标准。<br>商户类型代码表如下：<br>商户类型代码行业类型说明<br>4215邮递服务<br>4511民航<br>4722旅游<br>4782过桥费<br>4789其他运输服务<br>4614电信服务<br>5542加油站<br>5812餐馆<br>5999购物<br>6010金融机构－人工现金支付<br>6011金融机构－自动现金支付<br>6012金融机构－各类服务<br>7011酒店、旅馆<br>7299各类个人服务：洗衣、美容、<br>7399各类商业服务：停车场、租车、广告、其他服务<br>7699各类维修服务：维修、洗车、拖车<br>7996娱乐：电影、剧院、体育、游戏<br>8099医疗服务<br>8111法律服务<br>8999各类专业服务：会计、教育、装修、工程<br>选用条件：服务点终端发起的交易一定要有此域。<br>14，Bit22服务点输入方式(Point-of-Service Entry Mode)<br>位图位置：22<br>格式：定长<br>类型：N3<br>描述：在服务终端上定义PIN和PAN的输入方式。<br>服务点输入方式包含以下两个方面组合而成：<br>位置描述<br>1－2在服务终端上PAN有效期输入方式<br>3－3在服务终端上PIN的输入方式<br>PAN的输入方式编码如下：<br>PAN输入方式描述<br>00不知<br>01手工<br>02读磁卡<br>03条码扫描仪（BAR）<br>04光学符号阅读器（OCR）<br>05集成电路卡（IC卡）<br>PIN的输入方式编码如下：<br>PIN输入方式描述<br>0不知<br>1终端能接收PIN<br>2终端不能接收PIN<br>选用条件：服务点终端发起的交易一定要有此域。<br>15，Bit25服务点类型代码(Point-of-Service Condition Code)<br>位图位置：25<br>格式：定长<br>类型：N2<br>描述：定义交易发生的服务点类型<br>用法说明：下面是CYBERBANK支持的服务点条件代码。<br>服务点条件代码服务点终端类型<br>2自动柜员机（ATM）<br>10银行终端（10）<br>14POS<br>20电话银行<br>16，Bit32收单机构标识码(Acquirer institution Identification)<br>位图位置：32<br>格式：LLVAR<br>类型：N..11<br>描述：在金融交易中此域表示交易发生的银行机构的标识码<br>应答数据包必须和请求数据包此域相同。<br>17,Bit3向前机构标识码(Forwarding Institution Identification Code)<br>位图位置：33<br>格式：LLVAR<br>类型：N..11<br>描述：在金融交易中此域表示帐户所在的银行机构的标识码<br>在网管交易800/810中，本域含有交易发起机构的代码。<br>应答数据包必须和请求数据包此域相同。<br>18，Bit35二磁道数据(Track 2 Data)<br>位图位置：35<br>格式：LLVAR<br>类型：Z..37<br>描述：写在卡二磁道的数据。数据组成遵循ISO7811－1985标准，数据中包含域分隔符，但不包含卡启始、结束符、LRC等。<br>收卡行应检测卡的二磁道是否符合国际标准。<br>为支持国际交换收单行应将二磁道中的分隔符换为“＝”。除此外不能对二磁道数据进行任何修改，如修改PAN的校验字、有效期、服务码等。<br>19，Bit36三磁道数据(Track 3 Data)<br>位图位置：36<br>格式：LLLVAR<br>类型：Z…104<br>描述：写在卡三磁道的数据。数据应组成遵循ISO4909标准，数据中包含域分隔符，但不包含卡启始、结束符、LRC等。<br>注意：长度说明为3位数字长。<br>20，Bit37检索索引号(Retrieval Reference Number)<br>位图位置：37<br>格式：定长<br>类型：AN12<br>描述：检索索引号用来在任何时间标识一个金融、授权、自动冲正交易。<br>检索索引号不要求打印在持卡人的帐单上。它的主要目的是在收单行和授权行之间定义一个数据项用于跟踪和检索交易。授权机构可以将检索索引号打印在客户的对帐单上。<br>检索索引号由收单行分配。<br>选用条件：可包含在收单机构的交易请求中。如在交易请求中有，则应答数据中一定应原样返回。<br>21，Bit38授权码(Authorization Identification)<br>位图位置：38<br>格式：定长<br>类型：AN6<br>描述：交易授权机构返回的返回代码。<br>授权码用于在服务点终端上信用卡授权；<br>授权机构按网络操作规定，可选使用本域。<br>22，Bit39返回码(Response Code)<br>位图位置：39<br>格式：定长<br>类型：AN2<br>描述：对一交易定义其处理结果的编码。<br>返回码用于说明授权机构对金融（授权）交易的处理状态；也用来指明自动冲正交易的冲正原因；还用来指出目标主机已接收到文件修改、结算、管理、网管等交易请求。<br>返回码应尽可能准确，应尽可能描述清楚所遇到的问题和状态。网络交换主机、收单行主机有可能会按不同的返回码收取不同的交易处理费用，并执行不同的处理过程。<br>23，Bit41收卡单位终端标识码(Card Acceptor Terminal Identification)<br>位图位置：41<br>格式：定长<br>类型：ANS8<br>描述：定义在收单单位中定义一个服务终端的标识码，在同一商户中服务终端标识码应唯一。<br>24，Bit42收卡商户定义码(Card Acceptor Identification Code)<br>位图位置：42<br>格式：定长<br>类型：ANS15<br>描述：在本地和网络中定义交易单位（商户）的编码。<br>25，Bit43收卡商户位置(Card Acceptor Location)<br>位图位置：43<br>格式：定长<br>类型：ANS40<br>描述：在本地和网络中定义收卡单位（商户）的国家、省。城市等。<br>选用条件：如对外卡网络，一定要包含此域。<br>26，Bit44附加返回数据(Additional ResponseData)<br>位图位置：44<br>格式：LLVAR<br>类型：ANS..25<br>描述：在金融（授权）交易中授权机构返回的其他信息。<br>27，Bit48附加数据-私用(Additional Data-Private)<br>位图位置：48<br>格式：LLLVAR<br>类型：ANS…999<br>描述：银行电子服务系统使用此域作以下用途：<br>存放批量查询的返回数据<br>其格式与输出格式表对应<br>28，Bit49交易货币代码(Currency Code,Transaction)<br>位图位置：49<br>格式：定长<br>类型：AN3<br>描述：按ISO4217定义的交易货币代码，用来表示“交易金额”（field04）所用的货币种类。<br>交易货币代码是指在收单单位进行交易所用的交易种类。<br>29，Bit50结算货币代码(Currency Code,Settlement)<br>位图位置：50<br>格式：定长<br>类型：AN3<br>描述：按ISO4217定义的结算货币代码，用来表示结算金额、结算处理费、结算交易费等所用的货币种类。<br>结算货币代码是指在进行结算和清算过程中所用的货币种类。<br>30，Bit52用户密码(PIN)数据(PIN Data)<br>位图位置：52<br>格式：定长<br>类型：B16<br>描述：用户在服务终端上交易用于识别用户合法性的一些数字。<br>PIN在分行主机用分行主机密钥按ANSIX9.8标准加密，形成密文块。<br>选用条件：如果在终端上输入了密码，就需要此域。<br>31，Bit53密码相关控制信息(Security Related Control)<br>位图位置：53<br>格式：定长<br>类型：AN16<br>描述：本域提供有关密码块的附加信息，用于指出用于PIN计算的PIN key，用于MAC计算的MAC key。<br>本域格式如下表所示：<br>0－1格式代码2N“20”<br>2－3PIN加密算法2N“01”：DES<br>4－5密文块格式2N“01”:ANSI<br>6PIN密钥索引1N‘1’或‘2’<br>7MAC密钥索引1N‘1’或‘2’<br>8－11MAC检查数据4B<br>12－15填充4N<br>在BOC信用卡网络中PIN和MAC各使用两个密钥—-‘1’号和‘2’密钥，交易中计算PIN和MAC时只能各用某一个KEY，同时需将所用的KEY索引号填写此域。<br>选用条件：如果有PIN域或MAC域，一定需有此域。<br>32，Bit54附加金额(Additional Amounts)<br>位图位置：54<br>格式：LLLVAR<br>类型：ANS…120<br>描述：此域由授权行主机将客户的余额返回给收单终端，以显示或打印在客户回单上。<br>在此域中最多可有6个余额返回，每个余额返回格式如下：<br>位置描述<br>0－1处理码3－4或5－6位定义的帐号类型<br>2－3金额类型：01－帐户金额<br>02－可用金额<br>03－拥有金额<br>04－应付金额<br>40－可用取款限额<br>56－可用转帐限额<br>4－6金额的货币代码<br>7‘D’－借记金额，’C’－贷记金额<br>8－19余额数目<br>六个余额中必须返回可用余额，在ATM、POS上显示可用余额<br>33，Bit64信息确认码(MAC)<br>位图位置：64<br>格式：定长<br>类型：B16<br>描述：数据包的最后一个域，用于验证信息来源的合法性，以及数据包中数据是否未被篡改。<br>MAC的计算参ANSIX.99,(最后八字节未满八位者左补零，右补零？)<br>为提高效率，在发送者和接收者之间，只有以下一些重要的域参加MAC的计算。数据包中如果存在以下数据域，它们将参加MAC的计算。<br>位图域名<br>2基本帐号<br>3处理代码<br>4交易金额<br>11系统跟踪号<br>12本地交易时间<br>13本地交易日期<br>32收单机构代码<br>38授权码<br>39返回码<br>41收单终端代码<br>49交易货币代码<br>95替换金额<br>选用条件：只使用了1－64域的数据包使用此域。<br>34，Bit70管理信息码(System Management Indormation Code)<br>位图位置：70<br>格式：定长<br>类型：N3<br>描述：<br>用于定义和维护银行电子服务系统内部通讯网络状态和应用工作状态。<br>网络管理信息代码用于管理清算日期“cutoff”，通讯“sign on/sign off”，“key exchange”等。<br>支持以下一些网络管理信息码<br>NMIC网络管理信息码动作<br>001签到(Sign on)<br>002签退(Sign off)<br>101交换密钥(Key exchange)<br>201结帐日期切换(Cutoff)<br>202结帐日期切换完成<br>301测试(Echo test)<br>35，Bit74贷记交易笔数(Transaction Number)<br>位图位置：74<br>格式：定长<br>类型：N10<br>描述：贷记金融交易总的成功交易次数<br>CYBERBANK软件在收到如下一个处理代码时会增加贷记交易次数。<br>交易码交易服务<br>00贷记，购物与服务<br>01贷记，取现<br>02贷记，调整(客户调整)<br>36，Bit75贷记自动冲正交易笔数(Credits,Reversal Number)<br>位图位置：75<br>格式：定长<br>类型：N10<br>描述：贷记收单行自动冲正、“ChargeBack&quot;等交易总的交易次数<br>CYBERBANK软件在收到如下一个处理代码时会增加贷记自动冲正交易笔数<br>交易码交易服务<br>20贷记，退货<br>21贷记，存款<br>22贷记，调整（客户修改）<br>37，Bit76借记交易笔数(Debits,Number)<br>位图位置：76<br>格式：定长<br>类型：N10<br>描述：借记金融交易总的成功交易次数<br>CYBERBANK软件在收到如下一个处理代码时会增加借记交易次数。<br>交易码交易服务<br>00借记，购物与服务<br>01借记，取现<br>02借记，调整(客户调整)<br>38，Bit77借记自动冲正交易笔数(Debits,Reversal Number)<br>位图位置：77<br>格式：定长<br>类型：N10<br>描述：借记收单行自动冲正、“ChargeBack&quot;等交易总的交易次数<br>CYBERBANK软件在收到如下一个处理代码时会增加借记重发交易次数，并在清算表报中反映。<br>交易码交易服务<br>20借记(!!!)，退货<br>21借记，存款<br>22借记，调整（客户修改）<br>39，Bit78转帐交易笔数(Transfers,Number)<br>位图位置：78<br>格式：定长<br>类型：N10<br>描述：转帐的交易总次数。<br>系统在收到如下一个处理代码的金融交易时会增加转帐交易的次数。<br>交易码交易服务<br>40客户相关帐户间转帐<br>40，Bit79转帐自动冲正交易笔数(Transfers,Reversal Number)<br>位图位置：79<br>格式：定长<br>类型：N10<br>描述：转帐的自动冲正交易总次数。<br>系统在收到如下一个处理代码的自动冲正交易时会增加转帐自动冲正交易的次数。<br>交易码交易服务<br>40客户相关帐户间转帐<br>41，Bit80查询交易笔数(Inquiries,Number)<br>位图位置：80<br>格式：定长<br>类型：N10<br>描述：成功的查询交易次数。<br>系统软件在收到如下一个处理代码时会增加查询交易次数。<br>交易码交易服务<br>30查询可用金额<br>42，Bit81授权交易笔数(Authorization,Number)<br>位图位置：81<br>格式：定长<br>类型：N10<br>描述：成功的授权交易总额<br>在收到一个授权交易时系统将授权交易笔数加一。<br>43，Bit83贷记交易费金额(Credits,Transaction FeeAmount)<br>位图位置：83<br>格式：定长<br>类型：N12<br>描述：净交易费用，如交易金额为正。<br>44，Bit85借记交易费金额(Debits,Transaction FeeAmount)<br>位图位置：85<br>格式：定长<br>类型：N12<br>描述：净交易费用，如交易金额为负。<br>45，Bit86贷记交易金额(Credits,Amount)<br>位图位置：86<br>格式：定长<br>类型：N16<br>描述：贷记金融交易总的交易金额，不含任何费用。<br>系统在收到如下一个处理代码时会增加贷记交易金额，并在清算表报中反映。<br>交易码交易服务<br>20贷记，退货<br>21贷记，存款<br>22贷记，调整（客户修改）<br>46，Bit87贷记自动冲正金额(Credits,Reversal Amount)<br>位图位置：87<br>格式：定长<br>类型：N16<br>描述：信用卡自动冲正交易的总金额，不含任何费用。<br>47，Bit88借记交易金额(Debits,Amount)<br>位图位置：88<br>格式：定长<br>类型：N16<br>描述：借记金融交易总的交易金额，不含任何费用。<br>系统在收到如下一个处理代码时会增加借记交易金额，并在清算表报中反映。<br>交易码交易服务<br>00借记，购物与服务<br>01借记，取现<br>02借记，调整(客户调整)<br>48，Bit89借记自动冲正交易金额(Debits,Reversal Amount)<br>位图位置：89<br>格式：定长<br>类型：N16<br>描述：借记自动冲正交易的总金额，不含任何费用。<br>49，Bit90原交易的数据元素(Original Data Elements)<br>位图位置：90<br>格式：定长<br>类型：N42<br>描述：存放原交易的一些数据，用于修改或自动冲正。<br>数据由以下五部分组成：<br>位置描述<br>1－4信息类型码<br>设为原交易的信息类型代码<br>5－10系统跟踪号<br>原交易系统跟踪号<br>11－20交易日期和时间<br>原交易的交易日期和时间<br>21－31原收单机构<br>原交易的收单机构<br>不足11位的机构代码，左补‘0’<br>32－42原向前机构<br>原交易的收单机构<br>不足11位的机构代码，左补‘0’<br>50，Bit91文件修改编码(File Update Code)<br>位图位置：91<br>格式：定长<br>类型：AN1<br>描述：用此域指示某文件怎样维护。<br>CYBERBANK支持以下一些修改代码：<br>1增加记录<br>2改变记录<br>3删除记录<br>5查询<br>7增加文件<br>选用条件：<br>51，Bit94服务指示码(Service Indicator)<br>位图位置：94<br>格式：定长<br>类型：AN7<br>描述：指示文件修改服务。<br>选用条件：<br>52，Bit95代替金额(Replacement Amounts)<br>位图位置：95<br>格式：定长<br>类型：N42!!!<br>描述：客户修改或部分取消已完成的交易，最后实际发生的交易金额，<br>交易的原交易金额存放在90域。<br>本域由以下4部分组成<br>Sub-ElementAmountAttribute<br>交易实际金额N12<br>结算实际金额N12<br>实际交易费用X＋N8<br>实际结算费用X＋N8<br>53，Bit97净结算金额(Net Settlement Amount)<br>位图位置：97<br>格式：定长<br>类型：X+N16<br>描述：此域为净结帐金额。<br>502交易中用于发送当天的净结算金额<br>例：“C0000000020000000”，表示贷方（‘＋’？）200000.00元。<br>“D0000000020000000”，表示借方（‘－’？）200000.00元。<br>54，Bit99结算机构码(Settlement Institution Identification)<br>位图位置：99<br>格式：LLVAR<br>类型：N..11<br>描述：此域存放接收清算信息的机构代码。<br>返回数据包此域必须和请求数据包一致。<br>55，Bit100接收机构码（Receiving Institution Identification)<br>位图位置：100<br>格式：LLVAR<br>类型：N..11<br>描述：金融交易此域存放授权机构代码。<br>网管类交易，800/820交易，此域存放请求的目的机构代码。<br>返回数据包此域必须和请求数据包一致。<br>56，Bit101文件名(FileName)<br>位图位置：101<br>格式：LLVAR<br>类型：ANS..17<br>描述：发送机构设置的文件名。<br>57，Bit102帐号1(Account Identification1)<br>位图位置：102<br>格式：LLVAR<br>类型：ANS..28<br>描述：一个特定的客户帐号。帐号1用来描述受借记、转出、支付等交易影响的帐户。<br>选用条件：转帐时使用。<br>58，Bit103帐号2(Account Identiication2)<br>位图位置：103<br>格式：LLVAR<br>类型：ANS..28<br>描述：交易的补充信息，如：第二货币号、利率代码、起止日期等。<br>定义如下表<br>0000000000000000000000000000000000000000000000000<br>位置长度描述<br>00－2122帐户<br>22－276发卡机构号<br>如果此域存在，将按此机构代码作为路由信息。<br>选用条件：机构间转帐时使用。<br>60，Bit123新密码数据(New PIN Data)<br>位图位置：123<br>格式：LLLVAR<br>类型：B…16<br>描述：修改密码交易时存放新密码。<br>格式参考52域<br>选用条件：修改密码交易时必须有此域。<br>61，Bit128信息确认码(MAC)<br>位图位置：128<br>格式：定长<br>类型：B16<br>描述：数据包的最后一个域，用于验证信息来源的合法性，以及数据包中数据是否未被篡改。<br>MAC的计算参ANSIX.99<br>为提高效率，在发送者和接收者之间，只有以下一些重要的域参加MAC的计算。数据包中如果存在以下数据域，它们将参加MAC的计算。<br>位图域名<br>2基本帐号<br>3处理代码<br>4交易金额<br>11系统跟踪号<br>12本地交易时间<br>13本地交易日期<br>32收单机构代码<br>38授权码<br>39返回码<br>41收单终端代码<br>49交易货币代码<br>95替换金额<br>选用条件：使用65－128数据域的数据包需使用此域。 </p>
<p>消费交易实例:</p>
<p>消费交易，需要上送交易类型，卡号等等，定义如下<br>卡号 第2域 LLVAR BCD 5309987876545342<br>交易类型 第3域 长度6 BCD 900000<br>金额 第4域 长度12 BCD 100分<br>时间 第7域 长度8 BCD 20030802<br>2磁道信息 第35域 LLVAR ASCII 123456<br>3磁道信息 第36域 LLLVAR BCD 123456001<br>商户号 第41域 LLVAR ASCII 98765432<br>好了我们现在开始打包，首先按照长度和类型把上面的数据处理一下<br>卡号 165309987876545342<br>交易类型 900000<br>金额 000000000100<br>时间 20030802<br>2磁道 06313233343536<br>3磁道 0009123456001<br>商户号 083938373635343332<br>接下来我们按照域信息生成位图<br>因为有第2域，所以第二个位置是1，由第三域，所以第三个位置<br>是1，。。。<br>依此类推得到一串数字<br>0111 0010 0000 0000 0000 0000 0000 0000 0011 0000 1000 0000 0000 0000 0000 0000<br>转换过来，就是<br>72 00 00 00 30 80 00 00 这个就是BITMAP了<br>然后把上面的数据按照BITMAP+每个域的内容，依次排列<br>就得到这个包的内容了<br>7200000030800000165309987876545342900000000000000100<br>20030802063132333435360009123456001083938373635343332<br>前头再加上TPDU和MSGID就是最后的数据包</p>
<p>c++源代码:</p>
<p>\<bank8583.h\>:   </p>
<p>  #ifndef   __BANK_8583_H__<br>  #define   __BANK_8583_H__   </p>
<p>  #pragma   warning(   disable   :   4786)<br>  //identifier   was   truncated   to   ‘number’   characters   in   the   debug   information<br>  #include   “tchar.h”<br>  #include   “ttrace.h”<br>  #include   “basedef.h”<br>  #include   “public.h”<br>  #include   \<vector\><br>  #include   \<map\><br>  #include   \<list\><br>  using   namespace   std;   </p>
<p>  #include   “tsock.h”<br>  using   namespace   STDNS;   </p>
<p>  #define   F8583T_STR   0<br>  #define   F8583T_INT   1<br>  #define   F8583T_BIN   2<br>  typedef   struct   tagISO8583_FIELD<br>  {<br>  int   bit_flag;   //域数据类型0   —   string,   1   —   int,   2   —   binary<br>  char   *data_name;   //域名<br>  int   length;   //数据域长度<br>  int   length_in_byte;//实际长度（如果是变长）<br>  int   variable_flag;   //是否变长标志0：否   2：2位变长,3：3位变长<br>  int   datatyp;   //0   —   string,   1   —   int,   2   —   binary<br>  char   *data;   //存放具体值<br>  int   attribute;   //保留<br>  }   ISO8583_FIELD;<br>  void   Get8583Field(   int   index,   ISO8583_FIELD**   ppField   );<br>  void   Set8583ValidFields(   BYTE*   pindex   );   </p>
<p>  typedef   struct   tagTRADE_8583<br>  {<br>  const   char*   name;<br>  DWORD bankcode;<br>  BYTE bm[128];<br>  }TRADE_8583;   </p>
<p>  typedef   struct   tagTRADE_8583_DEF<br>  {<br>  DWORD   tcode;<br>  TRADE_8583   req;<br>  TRADE_8583   ans;<br>  }TRADE_8583_DEF;<br>  BOOL   Set8583TradeInfo(   TRADE_8583_DEF*   pInfo   );   </p>
<p>  typedef   vector\<BYTE\>   PACK_8583_ITEM;   </p>
<p>  class   Pack8583<br>  {<br>  public:<br>  Pack8583(   BOOL   bCompressInt   =   FALSE);<br>  virtual   ~Pack8583();<br>  BOOL   Init(DWORD   tcode);<br>  int   SetReqField(int   field,char*   buf,int   len);<br>  BOOL   BuildReqPack(   vector\<BYTE\>&amp;   A,   BOOL   bForceFillAll   =   TRUE   );<br>  BOOL   GetReqPackItem(   int   index,   PACK_8583_ITEM&amp;   item);   </p>
<p>  DWORD   GetReqBankCode();<br>  DWORD   GetAnsBankCode();<br>  //-1   package   is   not   full<br>  //-2   any   field   is   not   exist<br>  //-3   LVAR,LLVAR,LLLVAR的长度不是DIGIT<br>  //-4   LVAR,LLVAR,LLLVAR的长度太大<br>  int   UnPack(BYTE*   pack,int   len);//把缓冲区的数据解包到ansdata里<br>  //0   OK<br>  //1   time   out<br>  //2   recv   error<br>  //-3   LVAR,LLVAR,LLLVAR的长度不是DIGIT<br>  int   UnPack(   TCPSocket&amp;   sock   );//接收解包<br>  BOOL   GetAnsPackItem(   int   index,   PACK_8583_ITEM&amp;   item);   </p>
<p>  PACK_8583_ITEM*   GetFromReq(   int   index   );<br>  PACK_8583_ITEM*   GetFromAns(   int   index   );   </p>
<p>  void   ShowReq();<br>  void   ShowAns();<br>  char   m_recvbuf[1024];<br>  int   m_recvbytes;<br>  protected:<br>  BOOL   m_bCompInt;<br>  int   GetReqPackLen();<br>  BOOL   IsReqFieldValid(int);<br>  BOOL   IsAnsFieldValid(int);<br>  BOOL   IsReqFieldNotFill();   </p>
<p>  void   BuildReqMask(   BYTE*   mask,   BOOL   bext,   BYTE*   bm   );<br>  BOOL   IsReqExtExist();   </p>
<p>  void   MaskToBM(   BYTE*   mask,   BYTE*   bm   );//mask   BYTE[16],bm   BYTE[64]<br>  TRADE_8583_DEF*   m_pTradeDef;<br>  map\&lt;   int,   PACK_8583_ITEM   >   m_reqdata;<br>  map\&lt;   int,   PACK_8583_ITEM   >   m_ansdata;<br>  };   </p>
<p>  #endif</p>
<p>\<bank8583.cpp\>:<br>  #include   “stdafx.h”<br>  #include   \<stdio.h\><br>  #include   \<string.h\><br>  #include   \<assert.h\><br>  #include   “bank/bank8583.h”   </p>
<p>  ISO8583_FIELD   Tbl8583[128]   =<br>  {<br>  /*   FLD   1   */   {0,“BIT   MAP,EXTENDED   ”,   8,   0,   0,   2,   NULL,0},<br>  /*   FLD   2   */   {0,“PRIMARY   ACCOUNT   NUMBER   ”,   22,   0,   2,   1,   NULL,0},<br>  /*   FLD   3   */   {0,“PROCESSING   CODE   ”,   6,   0,   0,   1,   NULL,0},<br>  /*   FLD   4   */   {0,“AMOUNT,   TRANSACTION   ”,   12,   0,   0,   1,   NULL,0},<br>  /*   FLD   5   */   {0,“NO   USE   ”,   12,   0,   0,   1,   NULL,0},<br>  /*   FLD   6   */   {0,“NO   USE   ”,   12,   0,   0,   1,   NULL,0},<br>  /*   FLD   7   */   {0,“TRANSACTION   DATE   AND   TIME   ”,   10,   0,   0,   1,   NULL,0},<br>  /*   FLD   8   */   {0,“NO   USE   ”,   8,   0,   0,   1,   NULL,0},<br>  /*   FLD   9   */   {0,“NO   USE   ”,   8,   0,   0,   1,   NULL,0},<br>  /*   FLD   10   */   {0,“NO   USE   ”,   8,   0,   0,   1,   NULL,0},<br>  /*   FLD   11   */   {0,“SYSTEM   TRACE   AUDIT   NUMBER   ”,   6,   0,   0,   1,   NULL,0},<br>  /*   FLD   12   */   {0,“TIME,   LOCAL   TRANSACTION   ”,   6,   0,   0,   1,   NULL,0},<br>  /*   FLD   13   */   {0,“DATE,   LOCAL   TRANSACTION   ”,   4,   0,   0,   1,   NULL,0},<br>  /*   FLD   14   */   {0,“DATE,   EXPIRATION   ”,   4,   0,   0,   1,   NULL,0},<br>  /*   FLD   15   */   {0,“DATE,   SETTLEMENT   ”,   4,   0,   0,   1,   NULL,0},<br>  /*   FLD   16   */   {0,“NO   USE   ”,   4,   0,   0,   1,   NULL,0},<br>  /*   FLD   17   */   {0,“DATE,   CAPTURE   ”,   4,   0,   0,   1,   NULL,0},<br>  /*   FLD   18   */   {0,“MERCHANT&#39;S   TYPE   ”,   4,   0,   0,   1,   NULL,0},<br>  /*   FLD   19   */   {0,“NO   USE   ”,   3,   0,   0,   1,   NULL,0},<br>  /*   FLD   20   */   {0,“NO   USE   ”,   3,   0,   0,   1,   NULL,0},<br>  /*   FLD   21   */   {0,“NO   USE   ”,   3,   0,   0,   1,   NULL,0},<br>  /*   FLD   22   */   {0,“POINT   OF   SERVICE   ENTRY   MODE   ”,   3,   0,   0,   1,   NULL,0},<br>  /*   FLD   23   */   {0,“NO   USE   ”,   3,   0,   0,   1,   NULL,0},<br>  /*   FLD   24   */   {0,“NO   USE   ”,   3,   0,   0,   1,   NULL,0},<br>  /*   FLD   25   */   {0,“POINT   OF   SERVICE   CONDITION   CODE   ”,   2,   0,   0,   1,   NULL,0},<br>  /*   FLD   26   */   {0,“NO   USE   ”,   2,   0,   0,   1,   NULL,0},<br>  /*   FLD   27   */   {0,“NO   USE   ”,   1,   0,   0,   1,   NULL,0},<br>  /*   FLD   28   */   {0,“field27   ”,   6,   0,   0,   1,   NULL,0},<br>  /*   FLD   29   */   {0,“NO   USE   ”,   8,   0,   1,   1,   NULL,0},<br>  /*   FLD   30   */   {0,“NO   USE   ”,   8,   0,   1,   1,   NULL,0},<br>  /*   FLD   31   */   {0,“NO   USE   ”,   8,   0,   1,   1,   NULL,0},<br>  /*   FLD   32   */   {0,“ACQUIRER   INSTITUTION   ID.   CODE   ”,   11,   0,   2,   1,   NULL,0},<br>  /*   FLD   33   */   {0,“FORWARDING   INSTITUTION   ID.   CODE   ”,   11,   0,   2,   1,   NULL,0},<br>  /*   FLD   34   */   {0,“NO   USE   ”,   28,   0,   2,   0,   NULL,0},<br>  /*   FLD   35   */   {0,“TRACK   2   DATA   ”,   37,   0,   2,   0,   NULL,0},<br>  /*   FLD   36   */   {0,“TRACK   3   DATA   ”,104,   0,   3,   0,   NULL,0},<br>  /*   FLD   37   */   {0,“RETRIEVAL   REFERENCE   NUMBER   ”,   12,   0,   0,   0,   NULL,0},<br>  /*   FLD   38   */   {0,“AUTH.   IDENTIFICATION   RESPONSE   ”,   6,   0,   0,   0,   NULL,0},<br>  /*   FLD   39   */   {0,“RESPONSE   CODE   ”,   2,   0,   0,   0,   NULL,0},<br>  /*   FLD   40   */   {0,“NO   USE   ”,   3,   0,   0,   0,   NULL,0},<br>  /*   FLD   41   */   {0,“CARD   ACCEPTOR   TERMINAL   ID.   ”,   8,   0,   0,   0,   NULL,0},<br>  /*   FLD   42   */   {0,“CARD   ACCEPTOR   IDENTIFICATION   CODE   ”,   15,   0,   0,   0,   NULL,0},<br>  /*   FLD   43   */   {0,“CARD   ACCEPTOR   NAME   LOCATION   ”,   40,   0,   0,   0,   NULL,0},<br>  /*   FLD   44   */   {0,“ADDITIONAL   RESPONSE   DATA   ”,   25,   0,   2,   0,   NULL,0},<br>  /*   FLD   45   */   {0,“NO   USE   ”,   76,   0,   2,   0,   NULL,0},<br>  /*   FLD   46   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   47   */   {0,“field47   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   48   */   {0,“ADDITIONAL   DATA   —-   PRIVATE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   49   */   {0,“CURRENCY   CODE,TRANSACTION   ”,   3,   0,   0,   0,   NULL,0},<br>  /*   FLD   50   */   {0,“CURRENCY   CODE,SETTLEMENT   ”,   3,   0,   0,   0,   NULL,0},<br>  /*   FLD   51   */   {0,“NO   USE   ”,   3,   0,   0,   0,   NULL,0},<br>  /*   FLD   52   */   {0,“PERSONAL   IDENTIFICATION   NUMBER   DATA   ”,   8,   0,   0,   2,   NULL,0},<br>  /*   FLD   53   */   {0,“SECURITY   RELATED   CONTROL   INformATION”,   16,   0,   0,   1,   NULL,0},<br>  /*   FLD   54   */   {0,“ADDITIONAL   AMOUNTS   ”,120,   0,   3,   0,   NULL,0},<br>  /*   FLD   55   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   56   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   57   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   58   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   59   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   60   */   {0,“NO   USE   ”,   5,   0,   3,   0,   NULL,0},<br>  /*   FLD   61   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   62   */   {0,“NO   USE   ”,   11,   0,   3,   0,   NULL,0},<br>  /*   FLD   63   */   {0,“NO   USE   ”,   11,   0,   3,   0,   NULL,0},<br>  /*   FLD   64   */   {0,“MESSAGE   AUTHENTICATION   CODE   FIELD   ”,   8,   0,   0,   2,   NULL,0},<br>  /*   FLD   65   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   66   */   {0,“NO   USE   ”,   1,   0,   0,   1,   NULL,0},<br>  /*   FLD   67   */   {0,“NO   USE   ”,999,   0,   3,   1,   NULL,0},<br>  /*   FLD   68   */   {0,“NO   USE   ”,999,   0,   3,   1,   NULL,0},<br>  /*   FLD   69   */   {0,“NO   USE   ”,999,   0,   3,   1,   NULL,0},<br>  /*   FLD   70   */   {0,“SYSTEM   MANAGEMENT   INformATION   CODE   ”,   3,   0,   0,   1,   NULL,0},<br>  /*   FLD   71   */   {0,“NO   USE   ”,999,   0,   3,   1,   NULL,0},<br>  /*   FLD   72   */   {0,“NO   USE   ”,999,   0,   3,   1,   NULL,0},<br>  /*   FLD   73   */   {0,“NO   USE   ”,   6,   0,   0,   1,   NULL,0},<br>  /*   FLD   74   */   {0,“NUMBER   OF   CREDITS   ”,   10,   0,   0,   1,   NULL,0},<br>  /*   FLD   75   */   {0,“REVERSAL   NUMBER   OF   CREDITS   ”,   10,   0,   0,   1,   NULL,0},<br>  /*   FLD   76   */   {0,“NUMBER   OF   DEBITS   ”,   10,   0,   0,   1,   NULL,0},<br>  /*   FLD   77   */   {0,“REVERSAL   NUMBER   OF   DEBITS   ”,   10,   0,   0,   1,   NULL,0},<br>  /*   FLD   78   */   {0,“NUMBER   OF   TRANSFER   ”,   10,   0,   0,   1,   NULL,0},<br>  /*   FLD   79   */   {0,“REVERSAL   NUMBER   OF   TRANSFER   ”,   10,   0,   0,   1,   NULL,0},<br>  /*   FLD   80   */   {0,“NUMBER   OF   INQUIRS   ”,   10,   0,   0,   1,   NULL,0},<br>  /*   FLD   81   */   {0,“AUTHORIZATION   NUMBER   ”,   10,   0,   0,   1,   NULL,0},<br>  /*   FLD   82   */   {0,“NO   USE   ”,   12,   0,   0,   1,   NULL,0},<br>  /*   FLD   83   */   {0,“CREDITS,TRANSCATION   FEEAMOUNT   ”,   12,   0,   0,   1,   NULL,0},<br>  /*   FLD   84   */   {0,“NO   USE   ”,   12,   0,   0,   1,   NULL,0},<br>  /*   FLD   85   */   {0,“DEBITS,TRANSCATION   FEEAMOUNT   ”,   12,   0,   0,   1,   NULL,0},<br>  /*   FLD   86   */   {0,“AMOUNT   OF   CREDITS   ”,   16,   0,   0,   1,   NULL,0},<br>  /*   FLD   87   */   {0,“REVERSAL   AMOUNT   OF   CREDITS   ”,   16,   0,   0,   1,   NULL,0},<br>  /*   FLD   88   */   {0,“AMOUNT   OF   DEBITS   ”,   16,   0,   0,   1,   NULL,0},<br>  /*   FLD   89   */   {0,“REVERSAL   AMOUNT   OF   DEBITS   ”,   16,   0,   0,   1,   NULL,0},<br>  /*   FLD   90   */   {0,“ORIGINAL   DATA   ELEMENTS   ”,   42,   0,   0,   1,   NULL,0},<br>  /*   FLD   91   */   {0,“FILE   UPDATE   CODE   ”,   1,   0,   0,   0,   NULL,0},<br>  /*   FLD   92   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   93   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   94   */   {0,“SERVICE   INDICATOR   ”,   7,   0,   0,   0,   NULL,0},<br>  /*   FLD   95   */   {0,“REPLACEMENT   AMOUNTS   ”,   42,   0,   0,   0,   NULL,0},<br>  /*   FLD   96   */   {0,“NO   USE   ”,   8,   0,   0,   0,   NULL,0},<br>  /*   FLD   97   */   {0,“AMOUNT   OF   NET   SETTLEMENT   ”,   16,   0,   0,   0,   NULL,0},<br>  /*   FLD   98   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   99   */   {0,“SETTLEMENT   INSTITUTION   ID   ”,   11,   0,   2,   1,   NULL,0},<br>  /*   FLD   100   */   {0,“RECVEING   INSTITUTION   ID   ”,   11,   0,   2,   1,   NULL,0},<br>  /*   FLD   101   */   {0,“FILENAME   ”,   17,   0,   2,   0,   NULL,0},<br>  /*   FLD   102   */   {0,“ACCOUNT   IDENTIFICATION1   ”,   28,   0,   2,   0,   NULL,0},<br>  /*   FLD   103   */   {0,“ACCOUNT   IDENTIFICATION2   ”,   28,   0,   2,   0,   NULL,0},<br>  /*   FLD   104   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   105   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   106   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   107   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   108   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   109   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   110   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   111   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   112   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   113   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   114   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   115   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   116   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   117   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   118   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   119   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   120   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   121   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   122   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   123   */   {0,“NEW   PIN   DATA   ”,   8,   0,   3,   2,   NULL,0},<br>  /*   FLD   124   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   125   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   126   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   127   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   128   */   {0,“MESSAGE   AUTHENTICATION   CODE   FIELD   ”,   8,   0,   0,   2,   NULL,0},<br>  };<br>  void   Get8583Field(   int   index,   ISO8583_FIELD**   ppField   )<br>  {<br>  assert(   index>=1   &amp;&amp;   index   \&lt;=   128   );<br>  *ppField   =   &amp;Tbl8583[index-1];<br>  }<br>BYTE   g_8583ValidFields[16]   =   {0};<br>  void   Set8583ValidFields(   BYTE*   pindex   )<br>  {<br>  memset(   g_8583ValidFields,   0,   sizeof(g_8583ValidFields)   );   </p>
<p>  while(   *pindex   >=   1   &amp;&amp;   *pindex   \&lt;=   128   )<br>  {<br>  int   num   =   (*pindex)-1;<br>  int   n   =   num   /   8;<br>  BYTE   mask   =   0x80;<br>  mask   >>=   num   -   n   *   8;<br>  g_8583ValidFields[n]   |=   mask;<br>  pindex   ++;<br>  }<br>  }<br>  BOOL   IsValidField(   int   index   )<br>  {<br>  if(   index   >=   128   ||   index   \&lt;=   1   )   return   FALSE;<br>  int   num   =   index-1;<br>  int   n   =   num   /   8;<br>  BYTE   mask   =   0x80;<br>  mask   >>=   num   -   n   *   8;<br>  return   (   g_8583ValidFields[n]   &amp;   mask   );<br>  }   </p>
<p>  TRADE_8583_DEF*   g_8583TradeDef   =   NULL;   </p>
<p>  TRADE_8583_DEF*   Get8583TradeInfo(   DWORD   tcode   )<br>  {<br>  if(   g_8583TradeDef   ==   NULL   )<br>  {<br>  printf(&quot;Please   call   [Set8583TradeInfo]   function   first/r/n&quot;);<br>  return   NULL;<br>  }<br>  for(   int   i   =   0;   g_8583TradeDef[i].req.name   !=   NULL;   i   ++   )<br>  {<br>  if(   g_8583TradeDef[i].tcode   &amp;   tcode   )   return   &amp;g_8583TradeDef[i];<br>  }<br>  printf(&quot;   trade   not   find   !   /r/n&quot;);<br>  return   NULL;<br>  }   </p>
<p>  BOOL   Set8583TradeInfo(   TRADE_8583_DEF   *   pDef   )<br>  {<br>  g_8583TradeDef   =   NULL;<br>  for(   int   i   =   0   ;   pDef[i].req.name   !=   NULL   ;   i   ++   )<br>  {<br>  int   j;<br>  for(   j   =   0;   ;   j   ++   )<br>  {//保证所有的域都是声明了的<br>  int   index   =   pDef[i].req.bm[j];<br>  if(   index   >=   128   ||   index   \&lt;=   1   )   break;<br>  if(   !IsValidField(   index   )   )<br>  {<br>  printf(&quot;field[%d]   is   not   valid!/r/n&quot;,index);<br>  return   FALSE;<br>  }<br>  if(!(   Tbl8583[index-1].variable_flag   ==   0   ||<br>  Tbl8583[index-1].variable_flag   ==   1   ||<br>  Tbl8583[index-1].variable_flag   ==   2   ||<br>  Tbl8583[index-1].variable_flag   ==   3   )   )<br>  {<br>  printf(&quot;field[%d]   variable_flag   is   not   a   valid   number!/r/n&quot;,index);<br>  return   FALSE;<br>  }<br>  }<br>  }<br>  g_8583TradeDef   =   pDef;<br>  return   TRUE;<br>  }   </p>
<p>  Pack8583::Pack8583(   BOOL   bCompressInt   )<br>  {<br>  m_pTradeDef   =   NULL;<br>  m_bCompInt   =   bCompressInt;<br>  }   </p>
<p>  Pack8583::~Pack8583()<br>  {<br>  }   </p>
<p>  BOOL   Pack8583::Init(DWORD   tcode)<br>  {<br>  m_pTradeDef   =   Get8583TradeInfo(   tcode   );<br>  if(   m_pTradeDef   ==   NULL   )   return   FALSE;<br>  return   TRUE;<br>  }   </p>
<p>  BOOL   Pack8583::IsReqFieldValid(   int   field   )<br>  {<br>  for(   int   i   =   0   ;;   i   ++)<br>  {<br>  int   findex   =   m_pTradeDef->req.bm[i];<br>  if(   findex   \&lt;   0   ||   findex   >   128   )   break;<br>  if(   field   ==   findex   )   return   TRUE;<br>  }<br>  return   FALSE;<br>  }<br>  BOOL   Pack8583::IsAnsFieldValid(   int   field   )<br>  {<br>  for(   int   i   =   0   ;;   i   ++)<br>  {<br>  int   findex   =   m_pTradeDef->ans.bm[i];<br>  if(   findex   \&lt;   0   ||   findex   >   128   )   break;<br>  if(   field   ==   findex   )   return   TRUE;<br>  }<br>  return   FALSE;<br>  }<br>  BOOL   Pack8583::SetReqField(int   field,char*   buf,int   len)<br>  {<br>  if(   !IsReqFieldValid(   field)   )<br>  {<br>  printf(&quot;field   [%d]   is   not   valid!/r/n&quot;,field);<br>  return   FALSE;<br>  }   </p>
<p>  pair\&lt;   int,   PACK_8583_ITEM   >   item_insert;<br>  pair\&lt;   map\&lt;   int,   PACK_8583_ITEM   >::iterator,   BOOL   >   ret;   </p>
<p>  ISO8583_FIELD   &amp;F   =   Tbl8583[field-1];<br>  if(   F.variable_flag   ==   0   )<br>  {<br>  if(   len   !=   F.length   )<br>  {<br>  printf(&quot;field   [%d]   length   not   match!/r/n&quot;,field);<br>  return   FALSE;<br>  }<br>  }<br>  else<br>  {//1,2,3<br>  int   maxlen   =   0;<br>  if(   F.variable_flag   ==   1   )   maxlen   =   9;<br>  else   if(   F.variable_flag   ==   2   )   maxlen   =   99;<br>  else   if(   F.variable_flag   ==   3   )   maxlen   =   999;<br>  if(   len   >   maxlen   ||   len   \&lt;   0   )<br>  {<br>  printf(&quot;field   [%d]   data   length   out   of   range!/r/n&quot;,field);<br>  return   FALSE;<br>  }<br>  }   </p>
<p>  item_insert.first   =   field;<br>  ret   =   m_reqdata.insert(   item_insert   );<br>  PACK_8583_ITEM   &amp;item   =   ret.first->second;<br>  item.resize(   len   );<br>  memcpy(   &amp;item[0],   buf,   len   );<br>  return   TRUE;<br>  }<br>  PACK_8583_ITEM*   Pack8583::GetFromReq(   int   index   )<br>  {<br>  map\&lt;   int,   PACK_8583_ITEM   >   ::iterator   pos   =   m_reqdata.lower_bound(   index   );<br>  if(   pos   ==   m_reqdata.end()   ||   pos->first   !=   index   )   return   NULL;<br>  return   &amp;pos->second;<br>  }<br>  PACK_8583_ITEM*   Pack8583::GetFromAns(   int   index   )<br>  {<br>  map\&lt;   int,   PACK_8583_ITEM   >   ::iterator   pos   =   m_ansdata.lower_bound(   index   );<br>  if(   pos   ==   m_ansdata.end()   ||   pos->first   !=   index   )   return   NULL;<br>  return   &amp;pos->second;<br>  }   </p>
<p>  int   Pack8583::GetReqPackLen()<br>  {<br>  int   len   =   8;<br>  map\&lt;   int,   PACK_8583_ITEM   >::iterator   p;<br>  for(   p   =   m_reqdata.begin()   ;   p   !=   m_reqdata.end();   ++   p   )<br>  {<br>  int   findex   =   p->first;<br>  int   datalen   =   p->second.size();<br>  if(   m_bCompInt   &amp;&amp;   Tbl8583[findex-1].datatyp   ==   1   )<br>  {<br>  int   flen   =   Tbl8583[findex-1].variable_flag   +   datalen;<br>  len   +=   flen   /   2   +   flen   %   2;<br>  }<br>  else<br>  {<br>  len   +=   Tbl8583[findex-1].variable_flag;<br>  len   +=   datalen;<br>  }<br>  }<br>  if(   IsReqExtExist()   )   len   +=   8;<br>  return   len;<br>  }</p>
<p>C#的转换：</p>
<p>ASCII->string<br>Convert.ToInt32(ASCII);<br>Binary->string<br>Encoding.ASCII.GetString(Binary);</p>
<p>报文数据实例：</p>
<p>msgType：0200 30323030</p>
<p>1域:01110010 00111000 00000000 00010000 00110010 11000000 00010000 00001001</p>
<p>Bitmap:72 38 00 10 32 C0 10 09</p>
<p>2域:166224780001888456 313636323234373830303031383838343536</p>
<p>3域:000200 303030323030</p>
<p>4域:000000000001 303030303030303030303031</p>
<p>7域:0412103355 30343132313033333535</p>
<p>11域:000001 303030303031</p>
<p>12域:103355 313033333535</p>
<p>13域:0412 30343132</p>
<p>28域:C00000000 433030303030303030</p>
<p>35域:00 3030</p>
<p>36域:000 303030</p>
<p>41域:61006566 3631303036353636</p>
<p>42域: 860010030210013 383630303130303330323130303133</p>
<p>52 123456—06123456FFFFFFFF—C4F1029F060CA9B9—43344631303239463036304341394239</p>
<p>61域: 0186224780300001835 30313836323234373830333030303031383335</p>
<p>64域:4635BED3EC4B24C7</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-10-08T02:02:18.000Z"><a href="/2013/10/08/2013-04-22-f9ba07a0/">10月 8 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/10/08/2013-04-22-f9ba07a0/">VC中PCSC操作读卡器</a></h1>
  

    </header>
    <div class="entry">
      
        <p>1 引言</p>
<pre><code>完整的智能卡应用系统由后台服务程序、主机或终端应用程序和智能卡等组成，如图<span class="number">1</span>所示。其中，后台服务程序提供了支持智能卡的服务。例如，在一个电子付款系统中，后台服务程序可以提供到信用卡和帐户信息的访问；主机或终端应用程序一般存在于台式机或者终端、电子付款终端、手机或者一个安全子系统中，终端应用程序要处理用户、智能卡和后台服务程序之间的通讯；智能卡则存储用户的一些信息。

终端应用程序需要通过读卡器来访问智能卡，在一个系统中，通常存在多家厂商提供的读卡器，因此需要一个统一的读卡器设备驱动接口。

随着智能卡的广泛应用，为解决计算机与各种读卡器之间的互操作性问题，人们提出了PC<span class="regexp">/SC（Personal Computer/Smart Card）规范，PC/</span>SC规范作为读卡器和卡与计算机之间有一个标准接口，实现不同生产商的卡和读卡器之间的互操作性，其独立于设备的 API使得应用程序开发人员不必考虑当前实现形式和将来实现形式之间的差异，并避免了由于基本硬件改变而引起的应用程序变更，从而降低了软件开发成本。

Microsoft在其Platform SDK中实现了PC<span class="regexp">/SC，作为连接智能卡读卡器与计算机的一个标准模型，提供了独立于设备的 API，并与Windows平台集成。因此，我们可以用PC/</span>SC接口来访问智能卡。</code></pre>
<p>2 PC/SC概述</p>
<pre><code>PC/SC接口包含30多个以Scard为前缀的函数，所有函数的原型都在winscard.h中声明，应用程序需要包含winscard.lib，所有函数的正常返回值都是SCARD<span class="command">\_</span>S<span class="command">\_</span>SUCCESS。在这30多个函数中，常用的函数只有几个，与智能卡的访问流程（图2）对应，下面将详细介绍这些常用函数。</code></pre>
<p>3 PC/SC的使用</p>
<p>3.1建立资源管理器的上下文</p>
<pre><code>函数ScardEstablishContext()用于建立将在其中进行设备数据库操作的资源管理器上下文（范围）。

函数原型：LONG SCardEstablishContext(DWORD dwScope, LPCVOID pvReserved1, LPCVOID pvReserved2, LPSCARDCONTEXT phContext)<span class="comment">;</span>

各个参数的含义：</code></pre>
<p>（1）dwScope：输入类型；表示资源管理器上下文范围，取值为：SCARD_SCOPE_USER（在用户域中完成设备数据库操作）、SCARD_SCOPE_SYSTEM（在系统域中完成设备数据库操作）。要求应用程序具有相应的操作权限。</p>
<p>（2）pvReserved1：输入类型；保留，必须为NULL。</p>
<p>（3）pvReserved2：输入类型；保留，必须为NULL。</p>
<p>（4）phContext：输出类型；建立的资源管理器上下文的句柄。</p>
<p>下面是建立资源管理器上下文的代码：</p>
<pre><code><span class="title">SCARDCONTEXT</span>        hSC;

<span class="title">LONG</span>                          lReturn;

<span class="title">lReturn</span> = SCardEstablishContext(SCARD\_SCOPE\_USER, NULL, NULL, &amp;hSC);

<span class="title">if</span> ( lReturn!=SCARD\_S\_SUCCESS )

    printf(<span class="string">"Failed SCardEstablishContext\\n"</span>);</code></pre>
<p>3.2 获得系统中安装的读卡器列表</p>
<pre><code>函数ScardListReaders()可以列出系统中安装的读卡器的名字。

函数原型：LONG SCardListReaders(SCARDCONTEXT hContext, LPCTSTR mszGroups, LPTSTR mszReaders, LPDWORD pcchReaders)<span class="comment">;</span>

各个参数的含义：</code></pre>
<p>（1）hContext：输入类型；ScardEstablishContext()建立的资源管理器上下文的句柄，不能为NULL。</p>
<p>（2）mszGroups：输入类型；读卡器组名，为NULL时，表示列出所有读卡器。</p>
<p>（3）mszReaders：输出类型；系统中安装的读卡器的名字，各个名字之间用’\0’分隔，最后一个名字后面为两个连续的’\0’。</p>
<p>（4）pcchReaders：输入输出类型；mszReaders的长度。</p>
<pre><code>系统中可能安装多个读卡器，因此，需要保存各个读卡器的名字，以便以后与需要的读卡器建立连接。

下面是获得系统中安装的读卡器列表的代码：

<span class="keyword">char</span>               mszReaders[<span class="number">1024</span>];

LPTSTR               pReader, pReaderName[<span class="number">2</span>];

DWORD               dwLen=<span class="keyword">sizeof</span>(mzsReaders);

<span class="keyword">int</span>                         nReaders=<span class="number">0</span>;

lReturn = SCardListReaders(hSC, <span class="literal">NULL</span>, (LPTSTR)mszReaders, &amp;dwLen);

<span class="keyword">if</span> ( lReturn==SCARD\_S\_SUCCESS )

{

    pReader = (LPTSTR)pmszReaders;

    <span class="keyword">while</span> (\*pReader !=<span class="string">'\\0'</span> )

    {

        <span class="keyword">if</span> ( nReaders\&lt;<span class="number">2</span> ) <span class="comment">//使用系统中前2个读卡器</span>

            pReaderName[nReaders++]=pReader;

        printf(<span class="string">"Reader: %S\\n"</span>, pReader );

        <span class="comment">//下一个读卡器名</span>

        pReader = pReader + strlen(pReader) + <span class="number">1</span>;

    }

}</code></pre>
<p>3.3 与读卡器（智能卡）连接</p>
<pre><code>函数ScardConnect()在应用程序与读卡器上的智能卡之间建立一个连接。

函数原型：LONG SCardConnect(SCARDCONTEXT hContext, LPCTSTR szReader, DWORD dwShareMode, DWORD dwPreferredProtocols, LPSCARDHANDLE phCard, LPDWORD pdwActiveProtocol)<span class="comment">;</span>

各个参数的含义：</code></pre>
<p>（1）hContext：输入类型；ScardEstablishContext()建立的资源管理器上下文的句柄。</p>
<p>（2）szReader：输入类型；包含智能卡的读卡器名称（读卡器名称由ScardListReaders()给出）。</p>
<p>（3）dwShareMode：输入类型；应用程序对智能卡的操作方式，SCARD_SHARE_SHARED（多个应用共享同一个智能卡）、SCARD_SHARE_EXCLUSIVE（应用独占智能卡）、SCARD_SHARE_DIRECT（应用将智能卡作为私有用途，直接操纵智能卡，不允许其它应用访问智能卡）。</p>
<p>（4）dwPreferredProtocols：输入类型；连接使用的协议，SCARD_PROTOCOL_T0（使用T=0协议）、SCARD_PROTOCOL_T1（使用T=1协议）。</p>
<p>（5）phCard：输出类型；与智能卡连接的句柄。</p>
<p>（6）PdwActiveProtocol：输出类型；实际使用的协议。</p>
<pre><code>下面是与智能卡建立连接的代码：</code></pre>
<p>SCARDHANDLE          hCardHandle[2];</p>
<p>DWORD               dwAP;</p>
<p>lReturn = SCardConnect( hContext, pReaderName[0],    SCARD_SHARE_SHARED,</p>
<p>SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1, &amp;hCardHandle[0], &amp;dwAP );</p>
<p>if ( lReturn!=SCARD_S_SUCCESS )</p>
<p>{</p>
<pre><code><span class="function"><span class="title">printf</span><span class="params">(<span class="string">"Failed SCardConnect\\n"</span>)</span>;

<span class="title">exit</span><span class="params">(<span class="number">1</span>)</span>;</code></pre>
<p>}</p>
<p>与智能卡建立连接后，就可以向智能卡发送指令，与其交换数据了。</p>
<p>3.4 向智能卡发送指令</p>
<pre><code>函数ScardTransmit()向智能卡发送指令，并接受返回的数据。

函数原型：LONG SCardTransmit(SCARDHANDLE hCard, LPCSCARD<span class="command">\_</span>I0<span class="command">\_</span>REQUEST pioSendPci, LPCBYTE pbSendBuffer, DWORD cbSendLength, LPSCARD<span class="command">\_</span>IO<span class="command">\_</span>REQUEST pioRecvPci, LPBYTE pbRecvBuffer, LPDWORD pcbRecvLength);

各个参数的含义：</code></pre>
<p>（1）hCard：输入类型；与智能卡连接的句柄。</p>
<p>（2）pioSendPci：输入类型；指令的协议头结构的指针，由SCARD_IO_REQUEST结构定义。后面是使用的协议的协议控制信息。一般使用系统定义的结构，SCARD_PCI_T0（T=0协议）、SCARD_PCI_T1（T=1协议）、SCARD_PCI_RAW（原始协议）。</p>
<p>（3）pbSendBuffer：输入类型；要发送到智能卡的数据的指针。</p>
<p>（4）cbSendLength：输入类型；pbSendBuffer的字节数目。</p>
<p>（5）pioRecvPci：输入输出类型；指令协议头结构的指针，后面是使用的协议的协议控制信息，如果不返回协议控制信息，可以为NULL。</p>
<p>（6）pbRecvBuffer：输入输出类型；从智能卡返回的数据的指针。</p>
<p>（7）pcbRecvLength：输入输出类型；pbRecvBuffer的大小和实际大小。</p>
<pre><code>对于<span class="literal">T</span>=<span class="number">0</span>协议，收发缓冲的用法如下：</code></pre>
<p>（a）向智能卡发送数据：</p>
<pre><code>要向智能卡发送n<span class="command">\&gt;</span>0字节数据时，pbSendBuffer前4字节分别为T=0的CLA、INS、P1、P2，第5字节是n，随后是n字节的数据；cbSendLength值为n+5（4字节头+1字节Lc+n字节数据）。PbRecvBuffer将接收SW1、SW2状态码；pcbRecvLength值在调用时至少为2，返回后为2。</code></pre>
<p>BYTE             recvBuffer[260];</p>
<p>int                  sendSize, recvSize;</p>
<p>BTYE             sw1, sw2;</p>
<p>BYTE    select_mf[]={0xC0, 0xA4, 0x00, 0x00, 0x02, 0x3F, 0x00};</p>
<p>sendSize=7;</p>
<p>recvSize=sizeof(recvBuffer);</p>
<p>lReturn = SCardTransmit(hCardHandle[0], SCARD_PCI_T0, select_mf, sendSize,</p>
<p>NULL, recvBuffer, &amp;recvSize);</p>
<p>if ( lReturn != SCARD_S_SUCCESS )</p>
<p>{</p>
<pre><code><span class="function"><span class="title">printf</span><span class="params">(<span class="string">"Failed SCardTransmit\\n"</span>)</span>;

<span class="title">exit</span><span class="params">(<span class="number">1</span>)</span>;</code></pre>
<p>}</p>
<p>//返回的数据，recvSize=2</p>
<p>sw1=recvBuffer[recvSize-2];</p>
<p>sw2=recvBuffer[recvSize-1];</p>
<p>（b）从智能卡接收数据：</p>
<pre><code>为从智能卡接收n<span class="command">\&gt;</span>0字节数据，pbSendBuffer前4字节分别为T=0的CLA、INS、P1、P2，第5字节是n（即Le），如果从智能卡接收256字节，则第5字节为0；cbSendLength值为5（4字节头+1字节Le）。PbRecvBuffer将接收智能卡返回的n字节，随后是SW1、SW2状态码；pcbRecvLength的值在调用时至少为 n+2，返回后为n+2。</code></pre>
<p>BYTE          get_challenge[]={0x00, 0x84, 0x00, 0x00, 0x08};</p>
<p>sendSize=5;</p>
<p>recvSize=sizeof(recvBuffer);</p>
<p>lReturn = SCardTransmit(hCardHandle[0], SCARD_PCI_T0, get_challenge,</p>
<p>sendSize, NULL, recvBuffer, &amp;recvSize);</p>
<p>if ( lReturn != SCARD_S_SUCCESS )</p>
<p>{</p>
<pre><code><span class="function"><span class="title">printf</span><span class="params">(<span class="string">"Failed SCardTransmit\\n"</span>)</span>;

<span class="title">exit</span><span class="params">(<span class="number">1</span>)</span>;</code></pre>
<p>}</p>
<p>//返回的数据, recvSize=10</p>
<p>sw1=recvBuffer[recvSize-2];</p>
<p>sw2=recvBuffer[recvSize-1];</p>
<p>//data=recvBuffer[0]——recvBuffer[7]</p>
<p>（c）向智能卡发送没有数据交换的命令：</p>
<pre><code>应用程序既不向智能卡发送数据，也不从智能卡接收数据，pbSendBuffer前<span class="number">4</span>字节分别为<span class="literal">T</span>=<span class="number">0</span>的CLA、INS、P1、P2，不发送P3；cbSendLength值必须为<span class="number">4</span>。PbRecvBuffer从智能卡接收SW1、SW2状态码；pcbRecvLength值在调用时至少为<span class="number">2</span>，返回后为<span class="number">2</span>。</code></pre>
<p>BYTE    set_flag[]={0x80, 0xFE, 0x00, 0x00};</p>
<p>sendSize=4;</p>
<p>recvSize=sizeof(recvBuffer);</p>
<p>lReturn = SCardTransmit(hCardHandle[0], SCARD_PCI_T0, set_flag, sendSize,</p>
<p>NULL, recvBuffer, &amp;recvSize);</p>
<p>if ( lReturn != SCARD_S_SUCCESS )</p>
<p>{</p>
<pre><code><span class="function"><span class="title">printf</span><span class="params">(<span class="string">"Failed SCardTransmit\\n"</span>)</span>;

<span class="title">exit</span><span class="params">(<span class="number">1</span>)</span>;</code></pre>
<p>}</p>
<p>//返回的数据，recvSize=2</p>
<p>sw1=recvBuffer[recvSize-2];</p>
<p>sw2=recvBuffer[recvSize-1];</p>
<p>（d）向智能卡发送具有双向数据交换的命令：</p>
<pre><code><span class="literal">T</span>=<span class="number">0</span>协议中，应用程序不能同时向智能卡发送数据，并从智能卡接收数据，即发送到智能卡的指令中，不能同时有Lc和Le。

这只能分两步实现：向智能卡发送数据，接收智能卡返回的状态码，其中，SW2是智能卡将要返回的数据字节数目；从智能卡接收数据（指令为<span class="number">0x00</span>、<span class="number">0xC0</span>、<span class="number">0x00</span>、<span class="number">0x00</span>、Le）。</code></pre>
<p>BYTE      get_response={0x00, 0xc0, 0x00, 0x00, 0x00};</p>
<p>BYTE    internal_auth[]={0x00, 0x88, 0x00, 0x00, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};</p>
<p>sendSize=13;</p>
<p>recvSize=sizeof(recvBuffer);</p>
<p>lReturn = SCardTransmit(hCardHandle[0], SCARD_PCI_T0, internal_auth,</p>
<p>sendSize, NULL, recvBuffer, &amp;recvSize);</p>
<p>if ( lReturn != SCARD_S_SUCCESS )</p>
<p>{</p>
<pre><code><span class="function"><span class="title">printf</span><span class="params">(<span class="string">"Failed SCardTransmit\\n"</span>)</span>;

<span class="title">exit</span><span class="params">(<span class="number">1</span>)</span>;</code></pre>
<p>}</p>
<p>//返回的数据，recvSize=2</p>
<p>sw1=recvBuffer[recvSize-2];</p>
<p>sw2=recvBuffer[recvSize-1];</p>
<pre><code>   <span class="title">if</span> ( sw1!=0x61 )</code></pre>
<p>{</p>
<pre><code><span class="function"><span class="title">printf</span><span class="params">(<span class="string">"Failed Command\\n"</span>)</span>;

<span class="title">exit</span><span class="params">(<span class="number">1</span>)</span>;</code></pre>
<p>}</p>
<p>get_response[4]=sw2;</p>
<p>sendSize=5;</p>
<p>recvSize=sizeof(recvBuffer);</p>
<p>lReturn = SCardTransmit(hCardHandle[0], SCARD_PCI_T0, get_response,</p>
<p>sendSize, NULL, recvBuffer, &amp;recvSize);</p>
<p>if ( lReturn != SCARD_S_SUCCESS )</p>
<p>{</p>
<pre><code><span class="function"><span class="title">printf</span><span class="params">(<span class="string">"Failed SCardTransmit\\n"</span>)</span>;

<span class="title">exit</span><span class="params">(<span class="number">1</span>)</span>;</code></pre>
<p>}</p>
<p>//返回的数据，recvSize=10</p>
<p>sw1=recvBuffer[recvSize-2];</p>
<p>sw2=recvBuffer[recvSize-1];</p>
<p>//data=recvBuffer[0]——recvBuffer[7]</p>
<p>3.5 断开与读卡器（智能卡）的连接</p>
<pre><code>在与智能卡的数据交换完成后，可以使用函数ScardDisconnect()终止应用与智能卡之间的连接。

函数原型：LONG SCardDisconnect(SCARDHANDLE hCard, DWORD dwDisposition)<span class="comment">;</span>

各个参数的含义：</code></pre>
<p>（1）hCard：输入类型；与智能卡连接的句柄。</p>
<p>（2）dwDisposition：输入类型；断开连接时，对智能卡的操作，SCARD_LEAVE_CARD（不做任何操作）、SCARD_RESET_CARD（复位智能卡）、SCARD_UNPOWER_CARD（给智能卡掉电）、SCARD_EJECT_CARD（弹出智能卡）。</p>
<pre><code>下面是断开与智能卡连接的代码：</code></pre>
<p>lReturn = SCardDisconnect(hCardHandle[0], SCARD_LEAVE_CARD);</p>
<p>if ( lReturn != SCARD_S_SUCCESS )</p>
<p>{</p>
<pre><code><span class="function"><span class="title">printf</span><span class="params">(<span class="string">"Failed SCardDisconnect\\n"</span>)</span>;

<span class="title">exit</span><span class="params">(<span class="number">1</span>)</span>;</code></pre>
<p>}</p>
<p>3.6 释放资源管理上下文</p>
<pre><code>   在应用程序终止前时，应该调用函数ScardReleaseContext()释放资源管理器的上下文。

函数原型：LONG SCardReleaseContext(SCARDCONTEXT hContext)<span class="comment">;</span>

各个参数含义：</code></pre>
<p>（1）hContext：输入类型；ScardEstablishContext()建立的资源管理器上下文的句柄，不能为NULL。</p>
<p>下面是释放资源管理上下文的代码：</p>
<p>lReturn = SCardReleaseContext(hSC);</p>
<p>if ( lReturn!=SCARD_S_SUCCESS )</p>
<p>printf(&quot;Failed SCardReleaseContext\n&quot;);</p>
<p>4 小结</p>
<pre><code>以上介绍的通过PC/SC来操作智能卡的流程，可以封装在一个类中。例如，我们可以设计一个类:</code></pre>
<p>class CSmartReader</p>
<p>{</p>
<p>private:</p>
<pre><code><span class="title">SCARDCONTEXT</span> hSC;

<span class="title">LONG</span>                   lReturn;

<span class="title">char</span>               mszReaders[<span class="number">1024</span>];

<span class="title">LPTSTR</span>               pReader, pReaderName[<span class="number">2</span>];

<span class="title">DWORD</span>               dwLen;

<span class="title">int</span>                         nReaders, nCurrentReader;

<span class="title">SCARDHANDLE</span>          hCardHandle[<span class="number">2</span>];

<span class="title">DWORD</span>               dwAP;</code></pre>
<p>public:</p>
<pre><code>   CSmartReader(); <span class="comment">//建立上下文、取读卡器列表</span>

   \~CSmartReader(); <span class="comment">//释放上下文</span>

   <span class="keyword">void</span> SetCurrentReader(<span class="keyword">int</span> currentReader);

   <span class="keyword">int</span> GetReaders(); <span class="comment">//获得读卡器数目</span>

   <span class="keyword">int</span> ConnectReader(); <span class="comment">//与当前读卡器建立连接</span>

   <span class="keyword">int</span> DisConnectReader(); <span class="comment">//与当前读卡器断开连接</span>

   <span class="keyword">int</span> SendCommand(BYTE command[], <span class="keyword">int</span> commandLength, BYTE result[], <span class="keyword">int</span> \*resultLength); <span class="comment">//向读卡器发送命令，并接收返回的数据。返回值为sw</span></code></pre>
<p>};</p>
<pre><code>   这样，我们就可以方便地使用PC/SC接口了。</code></pre>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-10-08T02:02:18.000Z"><a href="/2013/10/08/2013-04-17-e783d9cf/">10月 8 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/10/08/2013-04-17-e783d9cf/">人生真是寂寞如雪</a></h1>
  

    </header>
    <div class="entry">
      
        <p>出自《温瑞安》的小说，貌似是神州奇侠之后有个网游小说人物的口头禅是这个，便给流行了。   </p>
<p>喻意就是： 人生就是美丽与短暂的组合，就像雪花一样，没有人能託在掌心细细欣赏，因为很快就融化了，人生就是如此的匆匆，还没等你回眸细细看清楚，自己已是百年身。（形容光阴飞奔，匆匆多年擦身而过，已然世事全非，百年只是藉用，也可解为垂暮）   </p>
<p>那种感受更是无人能够理解，而理解的人相对都已离（逝）去，所以活着就没人能懂身旁的人都离去的寂寞，只有无尽的等待自己也离去的那一天。 </p>
<p>如同雪花，天气放晴之时，默默融化在阳光下。</p>
<p>寂寞孤独什么的大概就是这个样子吧。 </p>
<p>这个样子是什么样子。 </p>
<p>有这样一个人。 </p>
<p>在你想找人陪你吃饭时会出现在你身边。 </p>
<p>在你长途旅行的途中会陪你发短信。 </p>
<p>在你晚上睡不著的时候会陪你聊天。 </p>
<p>在你心情不好的时候会逗你开心。 </p>
<p>在你不知道买哪件东西时会帮你做决定。 </p>
<p>在你哭泣的时候会递给你一张纸巾。 </p>
<p>在你无助的时候会给你支持和鼓励。 </p>
<p>在你没有方向的时候会为你亮一盏灯。   </p>
<p>但是总有一天生命走至某一处时就会是剩下一个人寂寞孤独。</p>
<p>陪你哭，陪你笑，陪你欢笑的人都一一为自己的生命走出你的世界‧而终就至最后就是孤独寂寞相伴。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-10-08T02:02:18.000Z"><a href="/2013/10/08/2013-04-17-b808af17/">10月 8 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/10/08/2013-04-17-b808af17/">Keil MDK编译器警告和错误详解</a></h1>
  

    </header>
    <div class="entry">
      
        <p>1.warning: #550-D: variable “d” was set but never used</p>
<p>描述:变量‘d’定义但从未使用,或者是,虽然这个变量你使用了,但编译器认为变量d所在的语句没有意义,编译器把它优化了.</p>
<p>解决:仔细衡量所定义的变量d是否有用,若是认定变量d所在语句有意义,那么尝试用volatile关键字修饰变量d,若是真的没有用,那么删除掉以释放可能的内存.</p>
<p>2.warning: #1-D: last line of file ends without a newline</p>
<p>描述:文件最后一行不是新的一行.编译器要求程序文件的最后一行必须是空行,想了半天没想通为什么要这样.</p>
<p>解决:可以不理会.若是觉得出现警告不爽,那么在出现警告的文件的最后一行敲个回车,空出一行.</p>
<p>​3. warning: #111-D: statement is unreachable</p>
<p>描述:声明不可能到达.多出现在这种场合:</p>
<p>int main(void)</p>
<p>{</p>
<p>…</p>
<p>while(1) //无限循环,这在不使用操作系统的程序中最常见</p>
<p>{</p>
<p>…</p>
<p>}</p>
<p>return 0; //这句声明在正常情况下不可能执行到,编译器发出警告</p>
<p>}</p>
<p>解决:不理会.</p>
<p>​4. warning: C3017W: data may be used before being set</p>
<p>描述:变量‘data’在使用前没有明确的赋值.如:</p>
<p>uint8 i,data; //定义变量i和data,二者都没有明确赋值</p>
<p>for ( i = 0; i \&lt; 8; i++) //变量‘i’在语句中被赋值0</p>
<p>{</p>
<p>if ( IO1PIN &amp; SO_CC2420 )</p>
<p>data |= 0x01; //变量‘data’在使用前没有明确赋值,编译器发出警告</p>
<p>else</p>
<p>data &amp;= ~0x01;</p>
<p>}</p>
<p>解决:应仔细衡量该变量的初始值是否为0，若是,可以不理会这个警告,因为MDK编译器在程序执行前,会将使用到的数据区初始化为0,但若是该变量的初始值不应该是0，忽略这个警告可能会引起致命错误.这个警告应引起足够重视.应养成变量赋初值的习惯,好在有编译器给把关.</p>
<p>​5. warning: #177-D: variable “temp” was declared but never referenced</p>
<p>描述:变量‘temp’进行了声明但没有引用.多出现在声明了一个变量,但却没有使用它,它和warning: #550-D: variable “temp” was set but never used不同之处在于temp从没有使用过.</p>
<p>解决:若是定义的变量确实没有用,删除掉;若是有用,则在程序中使用.</p>
<p>与该警告类似的还有 warning: #177-D: function “MACProcessBeacon” was declared but never referenced</p>
<p>​6. warning: #940-D: missing return statement at end of non-void function “DealwithInspect2”</p>
<p>描述:返回非空的函数“DealwithInspect2”的最后缺少返回值声明.如:</p>
<p>int DealwithInspect2(uint32 test)</p>
<p>{</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>//此处应该是return x;返回一个int型数据,若是没有返回值,编译器产生警告</p>
<p>}</p>
<p>7..warning: #1295-D: Deprecated declaration lcd_init - give arg types</p>
<p>描述:在定义函数的时候,如果你写上函数参数,就会有这个警告,比如void timer_init(); 这里就没有形参,如果这样的话,编译器会给出警告.</p>
<p>​1. error: #65: expected a “;”</p>
<p>描述:缺少分号.大多是漏忘‘;’.</p>
<p>解决:双击错误行,在定位到错误点的附近找到没加‘;’号的语句,加上分号.并不一定在定位到的错误行才却分号,可能是这行的上一行,也可能是下一行.</p>
<p>​2. error: #65: expected a “;”和 error: #20: identifier “xxxx” is undefined一块出现,而且后面的error: #20错误可能一大堆</p>
<p>描述:这个错误对于第一次遇上的人来说绝对是个噩梦,当错误出现,满怀希望的双击错误提示,来到错误行时却愕然发现,错误行绝对没有错,于是找找错误行的上一行,下一行,没有错误,再找上上行,下下行…让人无比郁闷的事情出现了:编译提示的所有错误行都不可能有错误出现.其实这最可能是你在.h文件声明外部变量或者函数时,没有在声明语句的最后加分号!如果你有很多模块,如main.c,lcd.c,key.c…有很多头文件,如lcd.h,key.h,若是在lcd.h文件声明函数时没有加分号,那么这种错误可能定为到main.c中,所以要检查所有头文件.</p>
<p>解决:仔细检查.h文件,将分号补上.</p>
<p>​3. Error: L6200E: Symbol flagu multiply defined (by uart0.o and main.o).</p>
<p>描述:变量(也是一种符号)flagu多处定义(在uart0.c中和main.c都定义了).通常错在全局变量定义重复.比如:在main.c中定义全局变量flagu:</p>
<p>uint8 flagu=0;</p>
<p>在uart0.c中也用到该变量,于是声明此变量,我通常都是先复制定义的变量再在变量前面加关键字extern修饰:</p>
<p>extern uint8 flagu=0;</p>
<p>然后编译,就会出现上面的连接错误,原因在于,我在uart0.c中是又定义了一个变量,而不是声明变量,因为我给变量赋了初值“flagu=0”,这样就重复定义了变量flag.正确的声明方法是去掉赋值部分:</p>
<p>extern uint8 flagu;</p>
<p>解决办法:找到重复定义的变量,看情况修改一处.</p>
<p>4.error: #159: declaration is incompatible with previous &quot;wr_lcd&quot; (declared at line 40)</p>
<p>描述:在wr_lcd函数还没有声明之前就已经使用了.多出现在两种情况:第一种,wr_lcd函数体还没有写,就已经用到了它,这种情况多出现在写一个程序的大体结构中,只是简单写一下框架.第二种情况比较常见,函数a调用函数b,但函数b的函数体在函数a的下面:</p>
<p>void a(void) //函数a的实体</p>
<p>{</p>
<p>b(); //调用函数b</p>
<p>}</p>
<p>void b(void) //函数b的实体</p>
<p>{</p>
<p>…</p>
<p>}</p>
<p>这样如果点编译,就会产生error: #159的错误,因为当函数a调用函数b时,发现在这之前都没有函数b的任何声明.</p>
<p>解决方法:在函数a调用函数b之前,对函数b进行声明,如:</p>
<p>void b(void); //对函数b进行声明</p>
<p>void a(void) //函数a的实体</p>
<p>{</p>
<p>b(); //调用函数b</p>
<p>}</p>
<p>void b(void) //函数b的实体</p>
<p>{</p>
<p>…</p>
<p>}</p>
<p>​5. error: #137: expression must be a modifiable lvalue</p>
<p>描述:表达式必须是一个可以修改的左值.主要出现在这种现象:</p>
<p>a=NUM;</p>
<p>NUM是一个数值或表达式,a为一个变量,但a被定义为像const这种不可更改的类型,导致NUM不能赋值给变量a.</p>
<p>解决方法:要么放弃赋值,要么修改变量属性.</p>
<p>6.error: #18: expected a “)”</p>
<p>如果是出现在c文件中, 多半是因为少了一个“)”,或者错误行有编译器不识别的字符</p>
<p>如果出现在头文件中,错误行又是一个函数声明,多半是因为在函数声明中有编译器不认识的字符</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




<nav id="pagination">
  
    <a href="/page/2/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/4/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:pnp2000.github.io">
  </form>
</div>

  

  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2013 NG
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>