<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 2 页 | NG's Blog</title>
  <meta name="author" content="NG">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="NG's Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="NG's Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">NG's Blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-10-08T02:02:18.000Z"><a href="/2013/10/08/2013-05-14-2/">10月 8 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/10/08/2013-05-14-2/">第二代身份证 - 是否在愚弄公民?</a></h1>
  

    </header>
    <div class="entry">
      
        <p>本人半个多月前发贴：[让中国人愤怒的第二代身份证] 幸得各位网友支持，成为论坛热帖。在此一并感谢。<br>此帖作为前帖的补充和总结，并提出新的论据，对第二代身份证相关的技术、经济和法律问题提出合理的质疑。<br>  引言<br>  第二代身份证究竟有何“优越”之处，以下是一篇有代表性的公开报道：<br>  （为了方便分析对照，下文中段落编号是笔者加上的。）<br>  1。中国第二代身份证是由公安部和信息产业部联合负责操作，属于非接触式IC卡，具有视读和机读两种功能，<br>总体分为硬件和软件两大系统，关键技术皆由公安机关指定的定点资格企业负责生产。<br>  2。第二代身份证中集成了一块专用芯片，居民的上述信息不仅仅被印在了卡片的表面，更是被直接“刻”进了卡片的心脏地带。通过这块芯片，第二代身份证可以与阅读身份证的机器进行相互认证，通过机读信息进行安全性确认；<br>  3。同时由于采用了这种芯片技术，第二代身份证的信息存储和证件查询具备了数据库技术和网络技术，因此也就可以实现全国范围内的联网快速查询和身份识别，大大提高了查询和识别的速度，并实现了信息共享。<br>  4。除此以外，由于第二代身份证的芯片预留了大量存储空间，随着社会发展的需要，公安机关还可以根据未来的需要录入更多的资料。未来的身份证会变得越来越智能，一张“居民身份证”就可以为多种社会服务提供身份识别的支持，方便大家的使用。<br>  5。目前在我国，今后市民在迁移户籍时将不再需要更换身份证，公安机关只要将相关内容写入芯片中就行了。至于今后我国身份证中还将记录怎样的信息，还需要依照相关的法律来具体确定。<br>  6。当然，要保证身份识别的安全性，仅仅靠现有的技术还是不够的。未来我们的身份证除了记录居民的个人基本资料之外，还将把诸如指纹信息、虹膜特征等生物特征信息一并记录下来。研究人员已开展了用于身份鉴别的人脸识别、话音识别、联机签名识别、指纹识别等多项研究工作，并取得了一定成效。<br>  7。第二代居民身份证引发巨大商机<br>  如果一张IC卡身份证按20元计，预计到2010年如期更换IC卡身份证规模达70%，届时将换发约8亿张IC卡身份证，市场规模就是160亿元。而且一旦IC卡身份证推行开来，将带动各种公共场所的终端需求。</p>
<pre><code>                                                    <span class="literal">-</span><span class="literal">-</span> <span class="comment">2004</span>-<span class="comment">08</span>-<span class="comment">26</span> <span class="comment">新闻晨报</span>  </code></pre>
<p>  一、第二代身份证在技术、经济方面的硬伤</p>
<p>  说其硬伤，就从上面第2点开始，既然身份证芯片记录了公民个人信息，那么先提一个问题：已经领了二代身份证的读者，你们有谁知道自己的身份证芯片中存储了什么信息？<br>  答案是否定的，作为公民个人，我们现在只能从表面看到，而根本无法得知身份证芯片中真正写了什么信息。<br>  这就是说，我们目前必须接受一个与自己密切有关而又不可知的东西。<br>  但是，将来不仅是执法部门，就连银行、宾馆等商业部门也可以允许读取、验证我们个人的信息。自己的信息却掌握在别人的手里，这又如何体现公民的隐私权？<br>  这个问题之所以被轻视，有过去顽固的习惯势力影响。多年以来，个人的人事档案就是对本人保密的，但在很多时候却决定一个人的人生命运。这种“传统”一直延续到身份证问题上。<br>  从技术上来体现这点似乎并不难，只要安装足够的读取身份证卡信息的设备，给每个公民提供验证信息机会就可以了。<br>  但这点在目前是做不到的，未来几年内也很难做到。做不到主要是因为经济上的原因。<br>  最早试行二代身份证的地区，已经将近两年，也没有普遍推广读卡机具。这是为何呢？<br>  请看上文第1条：关键技术皆由公安机关指定。。。<br>  身份证的关键技术，的确掌握在政府有关部门手中。但由于现今“产业垄断化”的潮流，这种关键技术实际上是通过政府部门下属“产业化”公司经营、有偿转让给使用者的。<br>  根据公开的市场信息，关键技术出让价格让许多有意参加身份证卡机具制作的企业望而却步。<br>  而接受了技术转让的企业，则进一步将此费用摊入产品成本，从而使生产的专用读卡机具市场价格高得惊人。<br>  于是地方公安部门便以价格太高为由，拒绝购买。当然他们有一个理由：既然是上面指定发放二代证，那么应该也由上面发放读卡机具。<br>  但市场上还是有人对此读卡机具感兴趣，主要是银行或一些新型服务企业。他们只是从商业角度考虑。<br>  这就不可避免地带来一个后果：将来二代身份证的用处，更多地体现在公民信息被出卖给商业部门利用！（见上文第7点）</p>
<p>  此问题将来如何解决？因为它是一个硬伤，所以实在没有好的办法解决。<br>  从办证费用来看，每个身份证至少20元（大多数地区加收超过20），但这20元，基本不可能用于读卡机具购买。已经有解释，这20元是全部用于身份证制作成本，不仅是卡商品成本，也包括其中的制作人工费。这种制作人工费是外请打工人员发生的。<br>  其实作为一项信息工程，费用还远不于此。除了机具外，还必须在背后建立联网的信息系统。（见上文第3点）。<br>  这就是说，除了20元或不止20元，国家还必须拨出一大笔财政款（由纳税人负担），来解决这个问题。<br>  这种款项预算将是十分巨大的。即使能够拨出，也要等多年以后。或许就此不了了之也有可能。</p>
<p>  也就是说，公民支出了费用，国家又化了大量人力、物力。<br>  而我们每个人手中得到的二代身份证，在今后相当长的年份里，只能当一张塑料卡片使用！<br>  与第一代身份证相比，它防伪功能要好，其它并没有多大差别。甚至在处理姓名的问题上，还不如第一代证用手写解决！<br>  读者中如果有谁还办过其它IC卡证件，就能体会到这种情况是必然会发生的。过去曾经有过多少个办IC卡证件而实际上无用的例子？！<br>  再说另一个技术上的硬伤：二代身份证的优越性，很大程度上是由其内部芯片储存信息来提供的。<br>  这种内部芯片“优越”的一个主要体现，就是内部信息可以改写，这在居民迁移户籍改写信息有用。（见上文第5点）<br>  但居民迁移户籍，居住地址肯定是要改的。尽管内部可以改写，而身份证表面却是无法改写的！<br>  身份证表面怎能不改？ 到时候怎么办？ 再让居民重办身份证？ 还是就此糊涂了之？<br>  因为身份证表面不能改写，就基本在目前否定了内部芯片的优越性。<br>  那么，又为何要设计这种内部芯片？ 它不仅是多余的问题，更主要的是因为这个芯片，造成读卡机具成本高昂。<br>  世界上怎能有如此不理性的技术经济分析和决策？<br>  二、第二代身份证在技术、经济、法律方面的软伤</p>
<p>  A。姓名权问题<br>  计算机难以处理中文冷僻字，最初是由于规划不周造成，现在则进一步延伸到身份证问题上。<br>  最早使用的GB2312-80国家标准，只能处理6000多个汉字。显然是一个很不重视中国文化的结果。<br>  把这个归咎于当时技术发展是推脱责任的，因为它主要是标准问题。而同期台湾BIG5系统却能处理13000多个汉字。<br>  而现在中文WINDOWS系统下，一般用的是GBK汉字库，它能处理两万多个汉字。令人啼笑皆非的是，GBK并不是真正的国家标准，只是为了应付中文信息处理急剧发展而临时定的规范。<br>  两万多个汉字不能解决冷僻字问题，所以公安部与有关部门研制开发了GB13000新字库，有3万多个汉字。但仍然无法完全解决冷僻字问题。<br>  未来的国家汉字信息标准将与国际标准CJK（中日韩）协同一致，总共含7万多个汉字。但要彻底解决冷僻字问题，必须首先要澄清一个问题：汉字个数最多究竟有多少？<br>  有一种说法是10万多个，但至今无法确切肯定。<br>  其实这预示了，二代身份证不能完善保证公民法律上的姓名权。<br>  对这个问题最好是不要遮掩，而是放开让全民讨论。<br>  但让公民什么都知情，似乎又不是我们的习惯做法。<br>  所以将来还会产生争议。<br>  B。安全性问题<br>  在报道文章第6条中说明：当然，要保证身份识别的安全性，仅仅靠现有的技术还是不够的。<br>  这是实事求是的说法。<br>  另有一种说法，认为伪造身份证比伪造钞票还难。<br>  其实这两者是不可比的。<br>  首先，二代身份证仍然属于非接触式IC卡（见上文第1条），虽然有我们自己的规范，但技术框架是建立在国际标准基础上的。<br>  现今中国掌握IC卡技术的厂家和人员比造钞票的要多得多。<br>  其次，要推广二代身份证应用，就必须引入更多的单位参与，并将部分技术秘密转给他们。<br>  应用越广，信息泄密的危险性也越大。这是一个两难抉择：要么更多方便，更少安全。要么相反。<br>  再者，IC卡相关技术还在发展，未来会进展到哪一步，还很难预料。<br>  那么如何应对这个问题？ 是否能象报道文章第6条所说，进一步引进更新的技术？用DNA识别技术？<br>  这会带来另外的弊端，一是公民失去更多的隐私，二是承担更大的负担。<br>  当然，这个问题还是不确定的，所以将其归为软伤。<br>  C。公民经济权益问题<br>  从以上种种情况看，二代身份证应用条件在中国并没有成熟。既然没有成熟，即是一个试验。<br>  那么，这样的试验直接向公民收费是否合适？<br>  但这点似乎没有多少讨论的机会。公用事业不断涨价的例子已经告诉我们，这类事情我们往往是无可奈何的。<br>  乱办证、乱收费最初都是由经济利益驱动而导致的。因为政府部门要养着一批人，要吃饭。<br>  第二代身份证最初的方案，便是由国家垄断生产。这个方案由于人大反对，而后来更改为向社会招标。</p>
<p>  D。公民隐私权问题<br>  这虽然只是一个潜在的问题，但按现代文明社会的标准，却是一个极其重要的问题。<br>  中国传统体制历来不重视人的隐私权，甚至于在文革中发展到“斗私批修”，要人自己把隐私揭露出来。是反人性的。<br>  其实，自由在很大程度上取于人的隐私权有多少。隐私权是现代人权最重要的部分之一。<br>  如前面报道，第二代身份证设计原义是在内包含更多的个人信息，如指纹信息、虹膜特征等生物特征。而身份证内含芯片现在的利用率，按常规估计不会到十分之一，其余空间可以预留给将来使用。<br>  我们能对这种潜在的侵权无动于衷吗？<br>  客观地说，隐私权也不是绝对不可放弃。例如在单位工作，工作时间原则上不应处理私事。<br>  于是打工者以放弃隐私为代价，换来了维持生存的收入。<br>  所以放弃隐私应该建立在自愿的原则基础上，同时应该获得必要的回报。<br>  但在未来身份证问题上，能保证我们有这样的选择吗？<br>  为此可以问一个问题，读者中有几个人知道，我们的身份证法是什么时候颁布的？ 里面又规定了什么具体内容？<br>  我想大多数人是不知道的。<br>  既然如此，将来隐私权的处理和规定情况会怎么变化，与你也不会有多大关系。<br>  这就是我们的现状。<br>  三、我们应当如何面对第二代身份证？</p>
<p>  面对第二代身份证将采取何种行动？我想不需要提出什么建议。每个成熟的公民自会作出自己合理的判断和选择。<br>  但实际上，目前不申领第二代身份证并不违反法律，持有第一代身份证仍然合法。<br>  如果我有机会，将对有关部门郑重提出如下建议：<br>  1。第二代身份证让公民采取自愿原则申领。<br>  2。无限期推迟第一代身份证停用时间。<br>  3。由于技术原因（例如由于迁户口改身份证，或IC卡技术原因）造成补领身份证，应该由行政机关承担费用。<br>  4。未来所有关于身份证变动的问题，应当先交由公民广泛讨论后再作决定。</p>
<h2>  这不仅是表达公民应有的权益，也是为了政府部门将来的工作着想。  </h2>
<p>  本帖初创于[猫眼看人]，转帖时请注明出处。<br>[参考资料]<br>A.中华人民共和国居民身份证法<br>B.新华网: 公安部通报换发第二代居民身份证有关情况<br>C.人民网>>专家文章: 中国第三代身份证将带指纹等生物识别特征<br>D.RFID(无线射频技术)世界网: 多篇有关第二代身份证的专业文章</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-10-08T02:02:18.000Z"><a href="/2013/10/08/2013-07-01-14/">10月 8 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/10/08/2013-07-01-14/">ISO8583协议-银行交易标准</a></h1>
  

    </header>
    <div class="entry">
      
        <p>ISO8583包（简称8583包）是一个国际标准的包格式，最多由128个字段域组成，每个域都有统一的规定，并有定长与变长之分。<br>      8583包前面一段为位图，用来确定包的字段域组成情况。<br>      其中位图是8583包的灵魂，它是打包解包确定字段域的关键， 而了解每个字段域的属性则是填写数据的基础。  </p>
<p>1、 位图描述如下：<br>位图位置：1<br>格式：定长<br>类型：B16（二进制16位，16*8=128bit）<br>描述：<br>    如将位图的第一位设为‘1’，表示使用扩展位图（128个域），否则表示只使用基本位图（64个域）。<br>    如使用某数据域，应在位图中将相应的位设位‘1’，如使用41域，需将位图的41位设为‘1’。<br>选用条件：如使用65到128域，需设位图域第一位为‘1’  </p>
<p>2、每个域的定义如下：<br>typedef struct ISO8583<br>{<br>     int bit_flag; /*域数据类型0 — string, 1 — int, 2 — binary*/<br>     char *data_name; /*域名*/<br>     int length; /*数据域长度*/<br>     int length_in_byte;/*实际长度（如果是变长）*/<br>     int variable_flag; /*是否变长标志0：否 2：2位变长, 3：3位变长*/<br>     int datatyp; /*0 — string, 1 — int, 2 — binary*/<br>     char *data; /*存放具体值*/<br>     int attribute; /*保留*/<br>} ISO8583;</p>
<p>ISO8583 Tbl8583[128] =<br>{<br>/* FLD 1 */ {0,“BIT MAP,EXTENDED ”, 8, 0, 0, 2, NULL,0},<br>/* FLD 2 */ {0,“PRIMARY ACCOUNT NUMBER ”, 22, 0, 2, 0, NULL,0},<br>/* FLD 3 */ {0,“PROCESSING CODE ”, 6, 0, 0, 0, NULL,0},<br>/* FLD 4 */ {0,“AMOUNT, TRANSACTION ”, 12, 0, 0, 1, NULL,0},<br>/* FLD 5 */ {0,“NO USE ”, 12, 0, 0, 0, NULL,0},<br>/* FLD 6 */ {0,“NO USE ”, 12, 0, 0, 0, NULL,0},<br>/* FLD 7 */ {0,“TRANSACTION DATE AND TIME ”, 10, 0, 0, 0, NULL,0},<br>/* FLD 8 */ {0,“NO USE ”, 8, 0, 0, 0, NULL,0},<br>/* FLD 9 */ {0,“NO USE ”, 8, 0, 0, 0, NULL,0},<br>/* FLD 10 */ {0,“NO USE ”, 8, 0, 0, 0, NULL,0},<br>/* FLD 11 */ {0,“SYSTEM TRACE AUDIT NUMBER ”, 6, 0, 0, 1, NULL,0},<br>/* FLD 12 */ {0,“TIME, LOCAL TRANSACTION ”, 6, 0, 0, 0, NULL,0},<br>/* FLD 13 */ {0,“DATE, LOCAL TRANSACTION ”, 4, 0, 0, 0, NULL,0},<br>/* FLD 14 */ {0,“DATE, EXPIRATION ”, 4, 0, 0, 0, NULL,0},<br>/* FLD 15 */ {0,“DATE, SETTLEMENT ”, 4, 0, 0, 0, NULL,0},<br>/* FLD 16 */ {0,“NO USE ”, 4, 0, 0, 0, NULL,0},<br>/* FLD 17 */ {0,“DATE, CAPTURE ”, 4, 0, 0, 0, NULL,0},<br>/* FLD 18 */ {0,“MERCHANT&#39;S TYPE ”, 4, 0, 0, 0, NULL,0},<br>/* FLD 19 */ {0,“NO USE ”, 3, 0, 0, 0, NULL,0},<br>/* FLD 20 */ {0,“NO USE ”, 3, 0, 0, 0, NULL,0},<br>/* FLD 21 */ {0,“NO USE ”, 3, 0, 0, 0, NULL,0},<br>/* FLD 22 */ {0,“POINT OF SERVICE ENTRY MODE ”, 3, 0, 0, 0, NULL,0},<br>/* FLD 23 */ {0,“NO USE ”, 3, 0, 0, 0, NULL,0},<br>/* FLD 24 */ {0,“NO USE ”, 3, 0, 0, 0, NULL,0},<br>/* FLD 25 */ {0,“POINT OF SERVICE CONDITION CODE ”, 2, 0, 0, 0, NULL,0},<br>/* FLD 26 */ {0,“NO USE ”, 2, 0, 0, 0, NULL,0},<br>/* FLD 27 */ {0,“NO USE ”, 1, 0, 0, 0, NULL,0},<br>/* FLD 28 */ {0,“field27 ”, 6, 0, 0, 0, NULL,0},<br>/* FLD 29 */ {0,“NO USE ”, 8, 0, 1, 0, NULL,0},<br>/* FLD 30 */ {0,“NO USE ”, 8, 0, 1, 0, NULL,0},<br>/* FLD 31 */ {0,“NO USE ”, 8, 0, 1, 0, NULL,0},<br>/* FLD 32 */ {0,“ACQUIRER INSTITUTION ID. CODE ”, 11, 0, 2, 0, NULL,0},<br>/* FLD 33 */ {0,“FORWARDING INSTITUTION ID. CODE ”, 11, 0, 2, 0, NULL,0},<br>/* FLD 34 */ {0,“NO USE ”, 28, 0, 2, 0, NULL,0},<br>/* FLD 35 */ {0,“TRACK 2 DATA ”, 37, 0, 2, 0, NULL,0},<br>/* FLD 36 */ {0,“TRACK 3 DATA ”,104, 0, 3, 0, NULL,0},<br>/* FLD 37 */ {0,“RETRIEVAL REFERENCE NUMBER ”, 12, 0, 0, 0, NULL,0},<br>/* FLD 38 */ {0,“AUTH. IDENTIFICATION RESPONSE ”, 6, 0, 0, 0, NULL,0},<br>/* FLD 39 */ {0,“RESPONSE CODE ”, 2, 0, 0, 0, NULL,0},<br>/* FLD 40 */ {0,“NO USE ”, 3, 0, 0, 0, NULL,0},<br>/* FLD 41 */ {0,“CARD ACCEPTOR TERMINAL ID. ”, 8, 0, 0, 0, NULL,0},<br>/* FLD 42 */ {0,“CARD ACCEPTOR IDENTIFICATION CODE ”, 15, 0, 0, 0, NULL,0},<br>/* FLD 43 */ {0,“CARD ACCEPTOR NAME LOCATION ”, 40, 0, 0, 0, NULL,0},<br>/* FLD 44 */ {0,“ADDITIONAL RESPONSE DATA ”, 25, 0, 2, 0, NULL,0},<br>/* FLD 45 */ {0,“NO USE ”, 76, 0, 2, 0, NULL,0},<br>/* FLD 46 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 47 */ {0,“field47 ”,999, 0, 3, 0, NULL,0},<br>/* FLD 48 */ {0,“ADDITIONAL DATA —- PRIVATE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 49 */ {0,“CURRENCY CODE,TRANSACTION ”, 3, 0, 0, 0, NULL,0},<br>/* FLD 50 */ {0,“CURRENCY CODE,SETTLEMENT ”, 3, 0, 0, 0, NULL,0},<br>/* FLD 51 */ {0,“NO USE ”, 3, 0, 0, 0, NULL,0},<br>/* FLD 52 */ {0,“PERSONAL IDENTIFICATION NUMBER DATA ”, 8, 0, 0, 2, NULL,0},<br>/* FLD 53 */ {0,“SECURITY RELATED CONTROL INformATION”, 16, 0, 0, 0, NULL,0},<br>/* FLD 54 */ {0,“ADDITIONAL AMOUNTS ”,120, 0, 3, 0, NULL,0},<br>/* FLD 55 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 56 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 57 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 58 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 59 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 60 */ {0,“NO USE ”, 5, 0, 3, 0, NULL,0},<br>/* FLD 61 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 62 */ {0,“NO USE ”, 11, 0, 3, 0, NULL,0},<br>/* FLD 63 */ {0,“NO USE ”, 11, 0, 3, 0, NULL,0},<br>/* FLD 64 */ {0,“MESSAGE AUTHENTICATION CODE FIELD ”, 8, 0, 0, 2, NULL,0},<br>/* FLD 65 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 66 */ {0,“NO USE ”, 1, 0, 0, 0, NULL,0},<br>/* FLD 67 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 68 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 69 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 70 */ {0,“SYSTEM MANAGEMENT INformATION CODE ”, 3, 0, 0, 0, NULL,0},<br>/* FLD 71 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 72 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 73 */ {0,“NO USE ”, 6, 0, 0, 0, NULL,0},<br>/* FLD 74 */ {0,“NUMBER OF CREDITS ”, 10, 0, 0, 0, NULL,0},<br>/* FLD 75 */ {0,“REVERSAL NUMBER OF CREDITS ”, 10, 0, 0, 0, NULL,0},<br>/* FLD 76 */ {0,“NUMBER OF DEBITS ”, 10, 0, 0, 0, NULL,0},<br>/* FLD 77 */ {0,“REVERSAL NUMBER OF DEBITS ”, 10, 0, 0, 0, NULL,0},<br>/* FLD 78 */ {0,“NUMBER OF TRANSFER ”, 10, 0, 0, 0, NULL,0},<br>/* FLD 79 */ {0,“REVERSAL NUMBER OF TRANSFER ”, 10, 0, 0, 0, NULL,0},<br>/* FLD 80 */ {0,“NUMBER OF INQUIRS ”, 10, 0, 0, 0, NULL,0},<br>/* FLD 81 */ {0,“AUTHORIZATION NUMBER ”, 10, 0, 0, 0, NULL,0},<br>/* FLD 82 */ {0,“NO USE ”, 12, 0, 0, 0, NULL,0},<br>/* FLD 83 */ {0,“CREDITS,TRANSCATION FEEAMOUNT ”, 12, 0, 0, 0, NULL,0},<br>/* FLD 84 */ {0,“NO USE ”, 12, 0, 0, 0, NULL,0},<br>/* FLD 85 */ {0,“DEBITS,TRANSCATION FEEAMOUNT ”, 12, 0, 0, 0, NULL,0},<br>/* FLD 86 */ {0,“AMOUNT OF CREDITS ”, 16, 0, 0, 0, NULL,0},<br>/* FLD 87 */ {0,“REVERSAL AMOUNT OF CREDITS ”, 16, 0, 0, 0, NULL,0},<br>/* FLD 88 */ {0,“AMOUNT OF DEBITS ”, 16, 0, 0, 0, NULL,0},<br>/* FLD 89 */ {0,“REVERSAL AMOUNT OF DEBITS ”, 16, 0, 0, 0, NULL,0},<br>/* FLD 90 */ {0,“ORIGINAL DATA ELEMENTS ”, 42, 0, 0, 0, NULL,0},<br>/* FLD 91 */ {0,“FILE UPDATE CODE ”, 1, 0, 0, 0, NULL,0},<br>/* FLD 92 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 93 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 94 */ {0,“SERVICE INDICATOR ”, 7, 0, 0, 0, NULL,0},<br>/* FLD 95 */ {0,“REPLACEMENT AMOUNTS ”, 42, 0, 0, 0, NULL,0},<br>/* FLD 96 */ {0,“NO USE ”, 8, 0, 0, 0, NULL,0},<br>/* FLD 97 */ {0,“AMOUNT OF NET SETTLEMENT ”, 16, 0, 0, 0, NULL,0},<br>/* FLD 98 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 99 */ {0,“SETTLEMENT INSTITUTION ID ”, 11, 0, 2, 0, NULL,0},<br>/* FLD 100 */ {0,“RECVEING INSTITUTION ID ”, 11, 0, 2, 0, NULL,0},<br>/* FLD 101 */ {0,“FILENAME ”, 17, 0, 2, 0, NULL,0},<br>/* FLD 102 */ {0,“ACCOUNT IDENTIFICATION1 ”, 28, 0, 2, 0, NULL,0},<br>/* FLD 103 */ {0,“ACCOUNT IDENTIFICATION2 ”, 28, 0, 2, 0, NULL,0},<br>/* FLD 104 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 105 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 106 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 107 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 108 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 109 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 110 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 111 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 112 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 113 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 114 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 115 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 116 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 117 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 118 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 119 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 120 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 121 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 122 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 123 */ {0,“NEW PIN DATA ”, 8, 0, 3, 2, NULL,0},<br>/* FLD 124 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 125 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 126 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 127 */ {0,“NO USE ”,999, 0, 3, 0, NULL,0},<br>/* FLD 128 */ {0,“MESSAGE AUTHENTICATION CODE FIELD ”, 8, 0, 0, 2, NULL,0},<br>}; </p>
<p>３、变长，定长域说明<br>如第二域：域名为主帐号，<br>数据类型为string<br>长度为22（是长长度不得超过此数）<br>是个２位变长域<br>由于是２位变长，在打包时需在数据域前加上数据的实际长度，如为１９位，则表示为：<br>１９＋数据值（即前两位为长度）<br>如第三域：域名为处理码，<br>数据类型为string<br>长度为６<br>是个定长域<br>必须填满６位。  </p>
<p>附A:ISO8583各域段的说明<br>1，信息类型（message type）定义<br>位图位置：－<br>格式：定长<br>类型：N4<br>描述：<br>数据包的第一部分，定义数据包的类型。<br>数据类型由数据包的发起者设定，应遵循以下要求：<br>数据包开始部分必须是信息类型；<br>对不支持的信息类型能给出拒绝应答。<br>0100授权交易<br>0110授权交易答复<br>0200金融交易<br>0210金融交易答复<br>0240查询交易<br>0250查询交易答复<br>0400冲正交易<br>0410冲正交易答复<br>0800管理交易<br>0810管理交易答复<br>2，位图(Bit Map) - 基本位图和扩展位图<br>位图位置：1<br>格式：定长<br>类型：B16<br>描述：<br>如将位图的第一位设为‘1’，表示使用扩展位图，否则表示只使用基本位图。<br>如使用某数据域，应在位图中将相应的位设位‘1’，如使用41域，需将位图的41位设为‘1’。<br>选用条件：如使用65到128域，需设位图域为‘1’<br>3、Bit02主帐号(Primary Account Number)</p>
<p>位图位置：02<br>格式：变长,LLVAR<br>类型：N..22<br>描述：<br>唯一的确认一个用户交易的基本帐号。<br>由于银行电子服务系统涉及多个应用系统，而帐号长度最多为22位，故将原标准的19长度改为22位。<br>4、Bit03 处理代码 （Processing Code）<br>位图位置：03<br>格式：定长<br>类型：N6<br>描述：用于描述交易对客户帐户造成何种影响的代码。<br>处理代码和信息码一起可唯一定义一种交易的类型。<br>处理代码由以下三部分组成：<br>位置描述<br>1－2交易动作码<br>3－4付出帐户类型，用于借记类，如查询、代收费、转场交易。<br>5－6收入帐户类型，用于代收费、转帐等。<br>其中：<br>ff : 付出帐户<br>tt： 收入帐户<br>* 视主机而定<br>5，Bit04 交易金额 （Amount, Transaction）<br>位图位置：04<br>格式：定长<br>类型：N12<br>描述：帐户人要求交易的交易金额，不含任何处理和交易费用。<br>金额的表示和货币代码有关，应能表示相应货币的最小单位。参ISO4217有关货币代码定义。<br>如“000000000100”用于表示美元，表示1.00元；如用于表示意大利货币，则表示100里拉。<br>对于查询等交易，应设交易金额为“000000000000”。<br>6，Bit06交易日期和时间（Transmission Date and Time）<br>位图位置：07<br>格式：定长，MMDDhhmmss<br>类型：N10<br>描述：本地交易日期和时间<br>7，Bit11系统跟踪号（Systems Trace Audit Number)<br>位图位置：11<br>格式：定长<br>类型：N6<br>描述：终端交易的跟踪号码。<br>交易发起终端填写，和“交易日期、时间”、信息类型等合在一起可唯一定义某一个终端的唯一一笔交易。即是说，在同一天，对一终端，同一类交易的系统跟踪号应保证不同。系统跟踪号在交易过程中不能修改。使用此域来匹配请求和通知类交易的返回。<br>应用系统使用此域来检查收到的授权、金融、自动冲正、结算、管理和网管等类交易的应答包是否是其请求包的应答。<br>系统跟踪号不用于匹配自动冲正交易，也不用于在预授权消费时匹配前面的预授权交易。参90域。<br>对于银行电子服务系统，其系统跟踪号是交易流水号。<br>8，Bit12本地交易时间（Time ,Local Transaction）<br>位图位置：12<br>格式：定长，hhmmss<br>类型：N6<br>描述：交易在终端上发生的时间。<br>本地交易时间在交易处理过程中不能改变。在自动冲正，存贮转发时，本地交易时间不能改变。<br>9，Bit13本地交易日期(Date ,Local Transaction)<br>位图位置：13<br>格式：定长,MMDD<br>类型：N4<br>描述：交易在终端上发生的时间。<br>本地交易时间不能改变，在自动冲正、存储转发交易时，本地交易时间也不能改变。<br>10，Bit14有效期(Date ,Expiration)<br>位图位置：14<br>格式：定长,YYMM<br>类型：N4<br>描述：卡的有效期，年年月月<br>由于卡类写磁格式不同，收单行可能提不出卡的有效期，授权机构从卡的二磁道中提取卡的有效期。如卡无二磁道，收单行应要求手工录入卡的有效期。<br>选用条件：100、200、400等交易如没有2、3磁道时，一定要有此域。<br>11，Bit15结算日期(Date ,Settlement)<br>位图位置：15<br>格式：定长，MMDD<br>类型：N4<br>描述：<br>银行电子服务系统和主机结算的时间，格式月月日日。<br>结帐日期前发生的交易参加当天结算。<br>在结算时，结帐日期也用于计算处理、交易费用。<br>12，Bit17获取日期(Date ,Capture)<br>位图位置：17<br>格式：定长，MMDD<br>类型：N4<br>描述：从主机获取交易的记帐日期。通常用于主机和商户清算。<br>13，Bit18商户类型（Merchant&#39;s Type）<br>位图位置：18<br>格式：定长<br>类型：N4<br>描述：定义商户产品和服务类型的代码<br>商户类型用于金融、授权交易，用于指定服务点的类型。它主要有以下用途：<br>决定预授权交易得到确认的最长时间；<br>控制合法限额；<br>为交易授权处理，控制网络操作规则；<br>欺诈检测；<br>用于商户分类报表；<br>交易费用处理。<br>根据ISO8583标准，应使用相应的国家标准。<br>商户类型代码表如下：<br>商户类型代码行业类型说明<br>4215邮递服务<br>4511民航<br>4722旅游<br>4782过桥费<br>4789其他运输服务<br>4614电信服务<br>5542加油站<br>5812餐馆<br>5999购物<br>6010金融机构－人工现金支付<br>6011金融机构－自动现金支付<br>6012金融机构－各类服务<br>7011酒店、旅馆<br>7299各类个人服务：洗衣、美容、<br>7399各类商业服务：停车场、租车、广告、其他服务<br>7699各类维修服务：维修、洗车、拖车<br>7996娱乐：电影、剧院、体育、游戏<br>8099医疗服务<br>8111法律服务<br>8999各类专业服务：会计、教育、装修、工程<br>选用条件：服务点终端发起的交易一定要有此域。<br>14，Bit22服务点输入方式(Point-of-Service Entry Mode)<br>位图位置：22<br>格式：定长<br>类型：N3<br>描述：在服务终端上定义PIN和PAN的输入方式。<br>服务点输入方式包含以下两个方面组合而成：<br>位置描述<br>1－2在服务终端上PAN有效期输入方式<br>3－3在服务终端上PIN的输入方式<br>PAN的输入方式编码如下：<br>PAN输入方式描述<br>00不知<br>01手工<br>02读磁卡<br>03条码扫描仪（BAR）<br>04光学符号阅读器（OCR）<br>05集成电路卡（IC卡）<br>PIN的输入方式编码如下：<br>PIN输入方式描述<br>0不知<br>1终端能接收PIN<br>2终端不能接收PIN<br>选用条件：服务点终端发起的交易一定要有此域。<br>15，Bit25服务点类型代码(Point-of-Service Condition Code)<br>位图位置：25<br>格式：定长<br>类型：N2<br>描述：定义交易发生的服务点类型<br>用法说明：下面是CYBERBANK支持的服务点条件代码。<br>服务点条件代码服务点终端类型<br>2自动柜员机（ATM）<br>10银行终端（10）<br>14POS<br>20电话银行<br>16，Bit32收单机构标识码(Acquirer institution Identification)<br>位图位置：32<br>格式：LLVAR<br>类型：N..11<br>描述：在金融交易中此域表示交易发生的银行机构的标识码<br>应答数据包必须和请求数据包此域相同。<br>17,Bit3向前机构标识码(Forwarding Institution Identification Code)<br>位图位置：33<br>格式：LLVAR<br>类型：N..11<br>描述：在金融交易中此域表示帐户所在的银行机构的标识码<br>在网管交易800/810中，本域含有交易发起机构的代码。<br>应答数据包必须和请求数据包此域相同。<br>18，Bit35二磁道数据(Track 2 Data)<br>位图位置：35<br>格式：LLVAR<br>类型：Z..37<br>描述：写在卡二磁道的数据。数据组成遵循ISO7811－1985标准，数据中包含域分隔符，但不包含卡启始、结束符、LRC等。<br>收卡行应检测卡的二磁道是否符合国际标准。<br>为支持国际交换收单行应将二磁道中的分隔符换为“＝”。除此外不能对二磁道数据进行任何修改，如修改PAN的校验字、有效期、服务码等。<br>19，Bit36三磁道数据(Track 3 Data)<br>位图位置：36<br>格式：LLLVAR<br>类型：Z…104<br>描述：写在卡三磁道的数据。数据应组成遵循ISO4909标准，数据中包含域分隔符，但不包含卡启始、结束符、LRC等。<br>注意：长度说明为3位数字长。<br>20，Bit37检索索引号(Retrieval Reference Number)<br>位图位置：37<br>格式：定长<br>类型：AN12<br>描述：检索索引号用来在任何时间标识一个金融、授权、自动冲正交易。<br>检索索引号不要求打印在持卡人的帐单上。它的主要目的是在收单行和授权行之间定义一个数据项用于跟踪和检索交易。授权机构可以将检索索引号打印在客户的对帐单上。<br>检索索引号由收单行分配。<br>选用条件：可包含在收单机构的交易请求中。如在交易请求中有，则应答数据中一定应原样返回。<br>21，Bit38授权码(Authorization Identification)<br>位图位置：38<br>格式：定长<br>类型：AN6<br>描述：交易授权机构返回的返回代码。<br>授权码用于在服务点终端上信用卡授权；<br>授权机构按网络操作规定，可选使用本域。<br>22，Bit39返回码(Response Code)<br>位图位置：39<br>格式：定长<br>类型：AN2<br>描述：对一交易定义其处理结果的编码。<br>返回码用于说明授权机构对金融（授权）交易的处理状态；也用来指明自动冲正交易的冲正原因；还用来指出目标主机已接收到文件修改、结算、管理、网管等交易请求。<br>返回码应尽可能准确，应尽可能描述清楚所遇到的问题和状态。网络交换主机、收单行主机有可能会按不同的返回码收取不同的交易处理费用，并执行不同的处理过程。<br>23，Bit41收卡单位终端标识码(Card Acceptor Terminal Identification)<br>位图位置：41<br>格式：定长<br>类型：ANS8<br>描述：定义在收单单位中定义一个服务终端的标识码，在同一商户中服务终端标识码应唯一。<br>24，Bit42收卡商户定义码(Card Acceptor Identification Code)<br>位图位置：42<br>格式：定长<br>类型：ANS15<br>描述：在本地和网络中定义交易单位（商户）的编码。<br>25，Bit43收卡商户位置(Card Acceptor Location)<br>位图位置：43<br>格式：定长<br>类型：ANS40<br>描述：在本地和网络中定义收卡单位（商户）的国家、省。城市等。<br>选用条件：如对外卡网络，一定要包含此域。<br>26，Bit44附加返回数据(Additional ResponseData)<br>位图位置：44<br>格式：LLVAR<br>类型：ANS..25<br>描述：在金融（授权）交易中授权机构返回的其他信息。<br>27，Bit48附加数据-私用(Additional Data-Private)<br>位图位置：48<br>格式：LLLVAR<br>类型：ANS…999<br>描述：银行电子服务系统使用此域作以下用途：<br>存放批量查询的返回数据<br>其格式与输出格式表对应<br>28，Bit49交易货币代码(Currency Code,Transaction)<br>位图位置：49<br>格式：定长<br>类型：AN3<br>描述：按ISO4217定义的交易货币代码，用来表示“交易金额”（field04）所用的货币种类。<br>交易货币代码是指在收单单位进行交易所用的交易种类。<br>29，Bit50结算货币代码(Currency Code,Settlement)<br>位图位置：50<br>格式：定长<br>类型：AN3<br>描述：按ISO4217定义的结算货币代码，用来表示结算金额、结算处理费、结算交易费等所用的货币种类。<br>结算货币代码是指在进行结算和清算过程中所用的货币种类。<br>30，Bit52用户密码(PIN)数据(PIN Data)<br>位图位置：52<br>格式：定长<br>类型：B16<br>描述：用户在服务终端上交易用于识别用户合法性的一些数字。<br>PIN在分行主机用分行主机密钥按ANSIX9.8标准加密，形成密文块。<br>选用条件：如果在终端上输入了密码，就需要此域。<br>31，Bit53密码相关控制信息(Security Related Control)<br>位图位置：53<br>格式：定长<br>类型：AN16<br>描述：本域提供有关密码块的附加信息，用于指出用于PIN计算的PIN key，用于MAC计算的MAC key。<br>本域格式如下表所示：<br>0－1格式代码2N“20”<br>2－3PIN加密算法2N“01”：DES<br>4－5密文块格式2N“01”:ANSI<br>6PIN密钥索引1N‘1’或‘2’<br>7MAC密钥索引1N‘1’或‘2’<br>8－11MAC检查数据4B<br>12－15填充4N<br>在BOC信用卡网络中PIN和MAC各使用两个密钥—-‘1’号和‘2’密钥，交易中计算PIN和MAC时只能各用某一个KEY，同时需将所用的KEY索引号填写此域。<br>选用条件：如果有PIN域或MAC域，一定需有此域。<br>32，Bit54附加金额(Additional Amounts)<br>位图位置：54<br>格式：LLLVAR<br>类型：ANS…120<br>描述：此域由授权行主机将客户的余额返回给收单终端，以显示或打印在客户回单上。<br>在此域中最多可有6个余额返回，每个余额返回格式如下：<br>位置描述<br>0－1处理码3－4或5－6位定义的帐号类型<br>2－3金额类型：01－帐户金额<br>02－可用金额<br>03－拥有金额<br>04－应付金额<br>40－可用取款限额<br>56－可用转帐限额<br>4－6金额的货币代码<br>7‘D’－借记金额，’C’－贷记金额<br>8－19余额数目<br>六个余额中必须返回可用余额，在ATM、POS上显示可用余额<br>33，Bit64信息确认码(MAC)<br>位图位置：64<br>格式：定长<br>类型：B16<br>描述：数据包的最后一个域，用于验证信息来源的合法性，以及数据包中数据是否未被篡改。<br>MAC的计算参ANSIX.99,(最后八字节未满八位者左补零，右补零？)<br>为提高效率，在发送者和接收者之间，只有以下一些重要的域参加MAC的计算。数据包中如果存在以下数据域，它们将参加MAC的计算。<br>位图域名<br>2基本帐号<br>3处理代码<br>4交易金额<br>11系统跟踪号<br>12本地交易时间<br>13本地交易日期<br>32收单机构代码<br>38授权码<br>39返回码<br>41收单终端代码<br>49交易货币代码<br>95替换金额<br>选用条件：只使用了1－64域的数据包使用此域。<br>34，Bit70管理信息码(System Management Indormation Code)<br>位图位置：70<br>格式：定长<br>类型：N3<br>描述：<br>用于定义和维护银行电子服务系统内部通讯网络状态和应用工作状态。<br>网络管理信息代码用于管理清算日期“cutoff”，通讯“sign on/sign off”，“key exchange”等。<br>支持以下一些网络管理信息码<br>NMIC网络管理信息码动作<br>001签到(Sign on)<br>002签退(Sign off)<br>101交换密钥(Key exchange)<br>201结帐日期切换(Cutoff)<br>202结帐日期切换完成<br>301测试(Echo test)<br>35，Bit74贷记交易笔数(Transaction Number)<br>位图位置：74<br>格式：定长<br>类型：N10<br>描述：贷记金融交易总的成功交易次数<br>CYBERBANK软件在收到如下一个处理代码时会增加贷记交易次数。<br>交易码交易服务<br>00贷记，购物与服务<br>01贷记，取现<br>02贷记，调整(客户调整)<br>36，Bit75贷记自动冲正交易笔数(Credits,Reversal Number)<br>位图位置：75<br>格式：定长<br>类型：N10<br>描述：贷记收单行自动冲正、“ChargeBack&quot;等交易总的交易次数<br>CYBERBANK软件在收到如下一个处理代码时会增加贷记自动冲正交易笔数<br>交易码交易服务<br>20贷记，退货<br>21贷记，存款<br>22贷记，调整（客户修改）<br>37，Bit76借记交易笔数(Debits,Number)<br>位图位置：76<br>格式：定长<br>类型：N10<br>描述：借记金融交易总的成功交易次数<br>CYBERBANK软件在收到如下一个处理代码时会增加借记交易次数。<br>交易码交易服务<br>00借记，购物与服务<br>01借记，取现<br>02借记，调整(客户调整)<br>38，Bit77借记自动冲正交易笔数(Debits,Reversal Number)<br>位图位置：77<br>格式：定长<br>类型：N10<br>描述：借记收单行自动冲正、“ChargeBack&quot;等交易总的交易次数<br>CYBERBANK软件在收到如下一个处理代码时会增加借记重发交易次数，并在清算表报中反映。<br>交易码交易服务<br>20借记(!!!)，退货<br>21借记，存款<br>22借记，调整（客户修改）<br>39，Bit78转帐交易笔数(Transfers,Number)<br>位图位置：78<br>格式：定长<br>类型：N10<br>描述：转帐的交易总次数。<br>系统在收到如下一个处理代码的金融交易时会增加转帐交易的次数。<br>交易码交易服务<br>40客户相关帐户间转帐<br>40，Bit79转帐自动冲正交易笔数(Transfers,Reversal Number)<br>位图位置：79<br>格式：定长<br>类型：N10<br>描述：转帐的自动冲正交易总次数。<br>系统在收到如下一个处理代码的自动冲正交易时会增加转帐自动冲正交易的次数。<br>交易码交易服务<br>40客户相关帐户间转帐<br>41，Bit80查询交易笔数(Inquiries,Number)<br>位图位置：80<br>格式：定长<br>类型：N10<br>描述：成功的查询交易次数。<br>系统软件在收到如下一个处理代码时会增加查询交易次数。<br>交易码交易服务<br>30查询可用金额<br>42，Bit81授权交易笔数(Authorization,Number)<br>位图位置：81<br>格式：定长<br>类型：N10<br>描述：成功的授权交易总额<br>在收到一个授权交易时系统将授权交易笔数加一。<br>43，Bit83贷记交易费金额(Credits,Transaction FeeAmount)<br>位图位置：83<br>格式：定长<br>类型：N12<br>描述：净交易费用，如交易金额为正。<br>44，Bit85借记交易费金额(Debits,Transaction FeeAmount)<br>位图位置：85<br>格式：定长<br>类型：N12<br>描述：净交易费用，如交易金额为负。<br>45，Bit86贷记交易金额(Credits,Amount)<br>位图位置：86<br>格式：定长<br>类型：N16<br>描述：贷记金融交易总的交易金额，不含任何费用。<br>系统在收到如下一个处理代码时会增加贷记交易金额，并在清算表报中反映。<br>交易码交易服务<br>20贷记，退货<br>21贷记，存款<br>22贷记，调整（客户修改）<br>46，Bit87贷记自动冲正金额(Credits,Reversal Amount)<br>位图位置：87<br>格式：定长<br>类型：N16<br>描述：信用卡自动冲正交易的总金额，不含任何费用。<br>47，Bit88借记交易金额(Debits,Amount)<br>位图位置：88<br>格式：定长<br>类型：N16<br>描述：借记金融交易总的交易金额，不含任何费用。<br>系统在收到如下一个处理代码时会增加借记交易金额，并在清算表报中反映。<br>交易码交易服务<br>00借记，购物与服务<br>01借记，取现<br>02借记，调整(客户调整)<br>48，Bit89借记自动冲正交易金额(Debits,Reversal Amount)<br>位图位置：89<br>格式：定长<br>类型：N16<br>描述：借记自动冲正交易的总金额，不含任何费用。<br>49，Bit90原交易的数据元素(Original Data Elements)<br>位图位置：90<br>格式：定长<br>类型：N42<br>描述：存放原交易的一些数据，用于修改或自动冲正。<br>数据由以下五部分组成：<br>位置描述<br>1－4信息类型码<br>设为原交易的信息类型代码<br>5－10系统跟踪号<br>原交易系统跟踪号<br>11－20交易日期和时间<br>原交易的交易日期和时间<br>21－31原收单机构<br>原交易的收单机构<br>不足11位的机构代码，左补‘0’<br>32－42原向前机构<br>原交易的收单机构<br>不足11位的机构代码，左补‘0’<br>50，Bit91文件修改编码(File Update Code)<br>位图位置：91<br>格式：定长<br>类型：AN1<br>描述：用此域指示某文件怎样维护。<br>CYBERBANK支持以下一些修改代码：<br>1增加记录<br>2改变记录<br>3删除记录<br>5查询<br>7增加文件<br>选用条件：<br>51，Bit94服务指示码(Service Indicator)<br>位图位置：94<br>格式：定长<br>类型：AN7<br>描述：指示文件修改服务。<br>选用条件：<br>52，Bit95代替金额(Replacement Amounts)<br>位图位置：95<br>格式：定长<br>类型：N42!!!<br>描述：客户修改或部分取消已完成的交易，最后实际发生的交易金额，<br>交易的原交易金额存放在90域。<br>本域由以下4部分组成<br>Sub-ElementAmountAttribute<br>交易实际金额N12<br>结算实际金额N12<br>实际交易费用X＋N8<br>实际结算费用X＋N8<br>53，Bit97净结算金额(Net Settlement Amount)<br>位图位置：97<br>格式：定长<br>类型：X+N16<br>描述：此域为净结帐金额。<br>502交易中用于发送当天的净结算金额<br>例：“C0000000020000000”，表示贷方（‘＋’？）200000.00元。<br>“D0000000020000000”，表示借方（‘－’？）200000.00元。<br>54，Bit99结算机构码(Settlement Institution Identification)<br>位图位置：99<br>格式：LLVAR<br>类型：N..11<br>描述：此域存放接收清算信息的机构代码。<br>返回数据包此域必须和请求数据包一致。<br>55，Bit100接收机构码（Receiving Institution Identification)<br>位图位置：100<br>格式：LLVAR<br>类型：N..11<br>描述：金融交易此域存放授权机构代码。<br>网管类交易，800/820交易，此域存放请求的目的机构代码。<br>返回数据包此域必须和请求数据包一致。<br>56，Bit101文件名(FileName)<br>位图位置：101<br>格式：LLVAR<br>类型：ANS..17<br>描述：发送机构设置的文件名。<br>57，Bit102帐号1(Account Identification1)<br>位图位置：102<br>格式：LLVAR<br>类型：ANS..28<br>描述：一个特定的客户帐号。帐号1用来描述受借记、转出、支付等交易影响的帐户。<br>选用条件：转帐时使用。<br>58，Bit103帐号2(Account Identiication2)<br>位图位置：103<br>格式：LLVAR<br>类型：ANS..28<br>描述：交易的补充信息，如：第二货币号、利率代码、起止日期等。<br>定义如下表<br>0000000000000000000000000000000000000000000000000<br>位置长度描述<br>00－2122帐户<br>22－276发卡机构号<br>如果此域存在，将按此机构代码作为路由信息。<br>选用条件：机构间转帐时使用。<br>60，Bit123新密码数据(New PIN Data)<br>位图位置：123<br>格式：LLLVAR<br>类型：B…16<br>描述：修改密码交易时存放新密码。<br>格式参考52域<br>选用条件：修改密码交易时必须有此域。<br>61，Bit128信息确认码(MAC)<br>位图位置：128<br>格式：定长<br>类型：B16<br>描述：数据包的最后一个域，用于验证信息来源的合法性，以及数据包中数据是否未被篡改。<br>MAC的计算参ANSIX.99<br>为提高效率，在发送者和接收者之间，只有以下一些重要的域参加MAC的计算。数据包中如果存在以下数据域，它们将参加MAC的计算。<br>位图域名<br>2基本帐号<br>3处理代码<br>4交易金额<br>11系统跟踪号<br>12本地交易时间<br>13本地交易日期<br>32收单机构代码<br>38授权码<br>39返回码<br>41收单终端代码<br>49交易货币代码<br>95替换金额<br>选用条件：使用65－128数据域的数据包需使用此域。 </p>
<p>消费交易实例:</p>
<p>消费交易，需要上送交易类型，卡号等等，定义如下<br>卡号 第2域 LLVAR BCD 5309987876545342<br>交易类型 第3域 长度6 BCD 900000<br>金额 第4域 长度12 BCD 100分<br>时间 第7域 长度8 BCD 20030802<br>2磁道信息 第35域 LLVAR ASCII 123456<br>3磁道信息 第36域 LLLVAR BCD 123456001<br>商户号 第41域 LLVAR ASCII 98765432<br>好了我们现在开始打包，首先按照长度和类型把上面的数据处理一下<br>卡号 165309987876545342<br>交易类型 900000<br>金额 000000000100<br>时间 20030802<br>2磁道 06313233343536<br>3磁道 0009123456001<br>商户号 083938373635343332<br>接下来我们按照域信息生成位图<br>因为有第2域，所以第二个位置是1，由第三域，所以第三个位置<br>是1，。。。<br>依此类推得到一串数字<br>0111 0010 0000 0000 0000 0000 0000 0000 0011 0000 1000 0000 0000 0000 0000 0000<br>转换过来，就是<br>72 00 00 00 30 80 00 00 这个就是BITMAP了<br>然后把上面的数据按照BITMAP+每个域的内容，依次排列<br>就得到这个包的内容了<br>7200000030800000165309987876545342900000000000000100<br>20030802063132333435360009123456001083938373635343332<br>前头再加上TPDU和MSGID就是最后的数据包</p>
<p>c++源代码:</p>
<p>\<bank8583.h\>:   </p>
<p>  #ifndef   __BANK_8583_H__<br>  #define   __BANK_8583_H__   </p>
<p>  #pragma   warning(   disable   :   4786)<br>  //identifier   was   truncated   to   ‘number’   characters   in   the   debug   information<br>  #include   “tchar.h”<br>  #include   “ttrace.h”<br>  #include   “basedef.h”<br>  #include   “public.h”<br>  #include   \<vector\><br>  #include   \<map\><br>  #include   \<list\><br>  using   namespace   std;   </p>
<p>  #include   “tsock.h”<br>  using   namespace   STDNS;   </p>
<p>  #define   F8583T_STR   0<br>  #define   F8583T_INT   1<br>  #define   F8583T_BIN   2<br>  typedef   struct   tagISO8583_FIELD<br>  {<br>  int   bit_flag;   //域数据类型0   —   string,   1   —   int,   2   —   binary<br>  char   *data_name;   //域名<br>  int   length;   //数据域长度<br>  int   length_in_byte;//实际长度（如果是变长）<br>  int   variable_flag;   //是否变长标志0：否   2：2位变长,3：3位变长<br>  int   datatyp;   //0   —   string,   1   —   int,   2   —   binary<br>  char   *data;   //存放具体值<br>  int   attribute;   //保留<br>  }   ISO8583_FIELD;<br>  void   Get8583Field(   int   index,   ISO8583_FIELD**   ppField   );<br>  void   Set8583ValidFields(   BYTE*   pindex   );   </p>
<p>  typedef   struct   tagTRADE_8583<br>  {<br>  const   char*   name;<br>  DWORD bankcode;<br>  BYTE bm[128];<br>  }TRADE_8583;   </p>
<p>  typedef   struct   tagTRADE_8583_DEF<br>  {<br>  DWORD   tcode;<br>  TRADE_8583   req;<br>  TRADE_8583   ans;<br>  }TRADE_8583_DEF;<br>  BOOL   Set8583TradeInfo(   TRADE_8583_DEF*   pInfo   );   </p>
<p>  typedef   vector\<BYTE\>   PACK_8583_ITEM;   </p>
<p>  class   Pack8583<br>  {<br>  public:<br>  Pack8583(   BOOL   bCompressInt   =   FALSE);<br>  virtual   ~Pack8583();<br>  BOOL   Init(DWORD   tcode);<br>  int   SetReqField(int   field,char*   buf,int   len);<br>  BOOL   BuildReqPack(   vector\<BYTE\>&amp;   A,   BOOL   bForceFillAll   =   TRUE   );<br>  BOOL   GetReqPackItem(   int   index,   PACK_8583_ITEM&amp;   item);   </p>
<p>  DWORD   GetReqBankCode();<br>  DWORD   GetAnsBankCode();<br>  //-1   package   is   not   full<br>  //-2   any   field   is   not   exist<br>  //-3   LVAR,LLVAR,LLLVAR的长度不是DIGIT<br>  //-4   LVAR,LLVAR,LLLVAR的长度太大<br>  int   UnPack(BYTE*   pack,int   len);//把缓冲区的数据解包到ansdata里<br>  //0   OK<br>  //1   time   out<br>  //2   recv   error<br>  //-3   LVAR,LLVAR,LLLVAR的长度不是DIGIT<br>  int   UnPack(   TCPSocket&amp;   sock   );//接收解包<br>  BOOL   GetAnsPackItem(   int   index,   PACK_8583_ITEM&amp;   item);   </p>
<p>  PACK_8583_ITEM*   GetFromReq(   int   index   );<br>  PACK_8583_ITEM*   GetFromAns(   int   index   );   </p>
<p>  void   ShowReq();<br>  void   ShowAns();<br>  char   m_recvbuf[1024];<br>  int   m_recvbytes;<br>  protected:<br>  BOOL   m_bCompInt;<br>  int   GetReqPackLen();<br>  BOOL   IsReqFieldValid(int);<br>  BOOL   IsAnsFieldValid(int);<br>  BOOL   IsReqFieldNotFill();   </p>
<p>  void   BuildReqMask(   BYTE*   mask,   BOOL   bext,   BYTE*   bm   );<br>  BOOL   IsReqExtExist();   </p>
<p>  void   MaskToBM(   BYTE*   mask,   BYTE*   bm   );//mask   BYTE[16],bm   BYTE[64]<br>  TRADE_8583_DEF*   m_pTradeDef;<br>  map\&lt;   int,   PACK_8583_ITEM   >   m_reqdata;<br>  map\&lt;   int,   PACK_8583_ITEM   >   m_ansdata;<br>  };   </p>
<p>  #endif</p>
<p>\<bank8583.cpp\>:<br>  #include   “stdafx.h”<br>  #include   \<stdio.h\><br>  #include   \<string.h\><br>  #include   \<assert.h\><br>  #include   “bank/bank8583.h”   </p>
<p>  ISO8583_FIELD   Tbl8583[128]   =<br>  {<br>  /*   FLD   1   */   {0,“BIT   MAP,EXTENDED   ”,   8,   0,   0,   2,   NULL,0},<br>  /*   FLD   2   */   {0,“PRIMARY   ACCOUNT   NUMBER   ”,   22,   0,   2,   1,   NULL,0},<br>  /*   FLD   3   */   {0,“PROCESSING   CODE   ”,   6,   0,   0,   1,   NULL,0},<br>  /*   FLD   4   */   {0,“AMOUNT,   TRANSACTION   ”,   12,   0,   0,   1,   NULL,0},<br>  /*   FLD   5   */   {0,“NO   USE   ”,   12,   0,   0,   1,   NULL,0},<br>  /*   FLD   6   */   {0,“NO   USE   ”,   12,   0,   0,   1,   NULL,0},<br>  /*   FLD   7   */   {0,“TRANSACTION   DATE   AND   TIME   ”,   10,   0,   0,   1,   NULL,0},<br>  /*   FLD   8   */   {0,“NO   USE   ”,   8,   0,   0,   1,   NULL,0},<br>  /*   FLD   9   */   {0,“NO   USE   ”,   8,   0,   0,   1,   NULL,0},<br>  /*   FLD   10   */   {0,“NO   USE   ”,   8,   0,   0,   1,   NULL,0},<br>  /*   FLD   11   */   {0,“SYSTEM   TRACE   AUDIT   NUMBER   ”,   6,   0,   0,   1,   NULL,0},<br>  /*   FLD   12   */   {0,“TIME,   LOCAL   TRANSACTION   ”,   6,   0,   0,   1,   NULL,0},<br>  /*   FLD   13   */   {0,“DATE,   LOCAL   TRANSACTION   ”,   4,   0,   0,   1,   NULL,0},<br>  /*   FLD   14   */   {0,“DATE,   EXPIRATION   ”,   4,   0,   0,   1,   NULL,0},<br>  /*   FLD   15   */   {0,“DATE,   SETTLEMENT   ”,   4,   0,   0,   1,   NULL,0},<br>  /*   FLD   16   */   {0,“NO   USE   ”,   4,   0,   0,   1,   NULL,0},<br>  /*   FLD   17   */   {0,“DATE,   CAPTURE   ”,   4,   0,   0,   1,   NULL,0},<br>  /*   FLD   18   */   {0,“MERCHANT&#39;S   TYPE   ”,   4,   0,   0,   1,   NULL,0},<br>  /*   FLD   19   */   {0,“NO   USE   ”,   3,   0,   0,   1,   NULL,0},<br>  /*   FLD   20   */   {0,“NO   USE   ”,   3,   0,   0,   1,   NULL,0},<br>  /*   FLD   21   */   {0,“NO   USE   ”,   3,   0,   0,   1,   NULL,0},<br>  /*   FLD   22   */   {0,“POINT   OF   SERVICE   ENTRY   MODE   ”,   3,   0,   0,   1,   NULL,0},<br>  /*   FLD   23   */   {0,“NO   USE   ”,   3,   0,   0,   1,   NULL,0},<br>  /*   FLD   24   */   {0,“NO   USE   ”,   3,   0,   0,   1,   NULL,0},<br>  /*   FLD   25   */   {0,“POINT   OF   SERVICE   CONDITION   CODE   ”,   2,   0,   0,   1,   NULL,0},<br>  /*   FLD   26   */   {0,“NO   USE   ”,   2,   0,   0,   1,   NULL,0},<br>  /*   FLD   27   */   {0,“NO   USE   ”,   1,   0,   0,   1,   NULL,0},<br>  /*   FLD   28   */   {0,“field27   ”,   6,   0,   0,   1,   NULL,0},<br>  /*   FLD   29   */   {0,“NO   USE   ”,   8,   0,   1,   1,   NULL,0},<br>  /*   FLD   30   */   {0,“NO   USE   ”,   8,   0,   1,   1,   NULL,0},<br>  /*   FLD   31   */   {0,“NO   USE   ”,   8,   0,   1,   1,   NULL,0},<br>  /*   FLD   32   */   {0,“ACQUIRER   INSTITUTION   ID.   CODE   ”,   11,   0,   2,   1,   NULL,0},<br>  /*   FLD   33   */   {0,“FORWARDING   INSTITUTION   ID.   CODE   ”,   11,   0,   2,   1,   NULL,0},<br>  /*   FLD   34   */   {0,“NO   USE   ”,   28,   0,   2,   0,   NULL,0},<br>  /*   FLD   35   */   {0,“TRACK   2   DATA   ”,   37,   0,   2,   0,   NULL,0},<br>  /*   FLD   36   */   {0,“TRACK   3   DATA   ”,104,   0,   3,   0,   NULL,0},<br>  /*   FLD   37   */   {0,“RETRIEVAL   REFERENCE   NUMBER   ”,   12,   0,   0,   0,   NULL,0},<br>  /*   FLD   38   */   {0,“AUTH.   IDENTIFICATION   RESPONSE   ”,   6,   0,   0,   0,   NULL,0},<br>  /*   FLD   39   */   {0,“RESPONSE   CODE   ”,   2,   0,   0,   0,   NULL,0},<br>  /*   FLD   40   */   {0,“NO   USE   ”,   3,   0,   0,   0,   NULL,0},<br>  /*   FLD   41   */   {0,“CARD   ACCEPTOR   TERMINAL   ID.   ”,   8,   0,   0,   0,   NULL,0},<br>  /*   FLD   42   */   {0,“CARD   ACCEPTOR   IDENTIFICATION   CODE   ”,   15,   0,   0,   0,   NULL,0},<br>  /*   FLD   43   */   {0,“CARD   ACCEPTOR   NAME   LOCATION   ”,   40,   0,   0,   0,   NULL,0},<br>  /*   FLD   44   */   {0,“ADDITIONAL   RESPONSE   DATA   ”,   25,   0,   2,   0,   NULL,0},<br>  /*   FLD   45   */   {0,“NO   USE   ”,   76,   0,   2,   0,   NULL,0},<br>  /*   FLD   46   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   47   */   {0,“field47   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   48   */   {0,“ADDITIONAL   DATA   —-   PRIVATE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   49   */   {0,“CURRENCY   CODE,TRANSACTION   ”,   3,   0,   0,   0,   NULL,0},<br>  /*   FLD   50   */   {0,“CURRENCY   CODE,SETTLEMENT   ”,   3,   0,   0,   0,   NULL,0},<br>  /*   FLD   51   */   {0,“NO   USE   ”,   3,   0,   0,   0,   NULL,0},<br>  /*   FLD   52   */   {0,“PERSONAL   IDENTIFICATION   NUMBER   DATA   ”,   8,   0,   0,   2,   NULL,0},<br>  /*   FLD   53   */   {0,“SECURITY   RELATED   CONTROL   INformATION”,   16,   0,   0,   1,   NULL,0},<br>  /*   FLD   54   */   {0,“ADDITIONAL   AMOUNTS   ”,120,   0,   3,   0,   NULL,0},<br>  /*   FLD   55   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   56   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   57   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   58   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   59   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   60   */   {0,“NO   USE   ”,   5,   0,   3,   0,   NULL,0},<br>  /*   FLD   61   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   62   */   {0,“NO   USE   ”,   11,   0,   3,   0,   NULL,0},<br>  /*   FLD   63   */   {0,“NO   USE   ”,   11,   0,   3,   0,   NULL,0},<br>  /*   FLD   64   */   {0,“MESSAGE   AUTHENTICATION   CODE   FIELD   ”,   8,   0,   0,   2,   NULL,0},<br>  /*   FLD   65   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   66   */   {0,“NO   USE   ”,   1,   0,   0,   1,   NULL,0},<br>  /*   FLD   67   */   {0,“NO   USE   ”,999,   0,   3,   1,   NULL,0},<br>  /*   FLD   68   */   {0,“NO   USE   ”,999,   0,   3,   1,   NULL,0},<br>  /*   FLD   69   */   {0,“NO   USE   ”,999,   0,   3,   1,   NULL,0},<br>  /*   FLD   70   */   {0,“SYSTEM   MANAGEMENT   INformATION   CODE   ”,   3,   0,   0,   1,   NULL,0},<br>  /*   FLD   71   */   {0,“NO   USE   ”,999,   0,   3,   1,   NULL,0},<br>  /*   FLD   72   */   {0,“NO   USE   ”,999,   0,   3,   1,   NULL,0},<br>  /*   FLD   73   */   {0,“NO   USE   ”,   6,   0,   0,   1,   NULL,0},<br>  /*   FLD   74   */   {0,“NUMBER   OF   CREDITS   ”,   10,   0,   0,   1,   NULL,0},<br>  /*   FLD   75   */   {0,“REVERSAL   NUMBER   OF   CREDITS   ”,   10,   0,   0,   1,   NULL,0},<br>  /*   FLD   76   */   {0,“NUMBER   OF   DEBITS   ”,   10,   0,   0,   1,   NULL,0},<br>  /*   FLD   77   */   {0,“REVERSAL   NUMBER   OF   DEBITS   ”,   10,   0,   0,   1,   NULL,0},<br>  /*   FLD   78   */   {0,“NUMBER   OF   TRANSFER   ”,   10,   0,   0,   1,   NULL,0},<br>  /*   FLD   79   */   {0,“REVERSAL   NUMBER   OF   TRANSFER   ”,   10,   0,   0,   1,   NULL,0},<br>  /*   FLD   80   */   {0,“NUMBER   OF   INQUIRS   ”,   10,   0,   0,   1,   NULL,0},<br>  /*   FLD   81   */   {0,“AUTHORIZATION   NUMBER   ”,   10,   0,   0,   1,   NULL,0},<br>  /*   FLD   82   */   {0,“NO   USE   ”,   12,   0,   0,   1,   NULL,0},<br>  /*   FLD   83   */   {0,“CREDITS,TRANSCATION   FEEAMOUNT   ”,   12,   0,   0,   1,   NULL,0},<br>  /*   FLD   84   */   {0,“NO   USE   ”,   12,   0,   0,   1,   NULL,0},<br>  /*   FLD   85   */   {0,“DEBITS,TRANSCATION   FEEAMOUNT   ”,   12,   0,   0,   1,   NULL,0},<br>  /*   FLD   86   */   {0,“AMOUNT   OF   CREDITS   ”,   16,   0,   0,   1,   NULL,0},<br>  /*   FLD   87   */   {0,“REVERSAL   AMOUNT   OF   CREDITS   ”,   16,   0,   0,   1,   NULL,0},<br>  /*   FLD   88   */   {0,“AMOUNT   OF   DEBITS   ”,   16,   0,   0,   1,   NULL,0},<br>  /*   FLD   89   */   {0,“REVERSAL   AMOUNT   OF   DEBITS   ”,   16,   0,   0,   1,   NULL,0},<br>  /*   FLD   90   */   {0,“ORIGINAL   DATA   ELEMENTS   ”,   42,   0,   0,   1,   NULL,0},<br>  /*   FLD   91   */   {0,“FILE   UPDATE   CODE   ”,   1,   0,   0,   0,   NULL,0},<br>  /*   FLD   92   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   93   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   94   */   {0,“SERVICE   INDICATOR   ”,   7,   0,   0,   0,   NULL,0},<br>  /*   FLD   95   */   {0,“REPLACEMENT   AMOUNTS   ”,   42,   0,   0,   0,   NULL,0},<br>  /*   FLD   96   */   {0,“NO   USE   ”,   8,   0,   0,   0,   NULL,0},<br>  /*   FLD   97   */   {0,“AMOUNT   OF   NET   SETTLEMENT   ”,   16,   0,   0,   0,   NULL,0},<br>  /*   FLD   98   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   99   */   {0,“SETTLEMENT   INSTITUTION   ID   ”,   11,   0,   2,   1,   NULL,0},<br>  /*   FLD   100   */   {0,“RECVEING   INSTITUTION   ID   ”,   11,   0,   2,   1,   NULL,0},<br>  /*   FLD   101   */   {0,“FILENAME   ”,   17,   0,   2,   0,   NULL,0},<br>  /*   FLD   102   */   {0,“ACCOUNT   IDENTIFICATION1   ”,   28,   0,   2,   0,   NULL,0},<br>  /*   FLD   103   */   {0,“ACCOUNT   IDENTIFICATION2   ”,   28,   0,   2,   0,   NULL,0},<br>  /*   FLD   104   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   105   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   106   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   107   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   108   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   109   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   110   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   111   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   112   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   113   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   114   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   115   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   116   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   117   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   118   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   119   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   120   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   121   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   122   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   123   */   {0,“NEW   PIN   DATA   ”,   8,   0,   3,   2,   NULL,0},<br>  /*   FLD   124   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   125   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   126   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   127   */   {0,“NO   USE   ”,999,   0,   3,   0,   NULL,0},<br>  /*   FLD   128   */   {0,“MESSAGE   AUTHENTICATION   CODE   FIELD   ”,   8,   0,   0,   2,   NULL,0},<br>  };<br>  void   Get8583Field(   int   index,   ISO8583_FIELD**   ppField   )<br>  {<br>  assert(   index>=1   &amp;&amp;   index   \&lt;=   128   );<br>  *ppField   =   &amp;Tbl8583[index-1];<br>  }<br>BYTE   g_8583ValidFields[16]   =   {0};<br>  void   Set8583ValidFields(   BYTE*   pindex   )<br>  {<br>  memset(   g_8583ValidFields,   0,   sizeof(g_8583ValidFields)   );   </p>
<p>  while(   *pindex   >=   1   &amp;&amp;   *pindex   \&lt;=   128   )<br>  {<br>  int   num   =   (*pindex)-1;<br>  int   n   =   num   /   8;<br>  BYTE   mask   =   0x80;<br>  mask   >>=   num   -   n   *   8;<br>  g_8583ValidFields[n]   |=   mask;<br>  pindex   ++;<br>  }<br>  }<br>  BOOL   IsValidField(   int   index   )<br>  {<br>  if(   index   >=   128   ||   index   \&lt;=   1   )   return   FALSE;<br>  int   num   =   index-1;<br>  int   n   =   num   /   8;<br>  BYTE   mask   =   0x80;<br>  mask   >>=   num   -   n   *   8;<br>  return   (   g_8583ValidFields[n]   &amp;   mask   );<br>  }   </p>
<p>  TRADE_8583_DEF*   g_8583TradeDef   =   NULL;   </p>
<p>  TRADE_8583_DEF*   Get8583TradeInfo(   DWORD   tcode   )<br>  {<br>  if(   g_8583TradeDef   ==   NULL   )<br>  {<br>  printf(&quot;Please   call   [Set8583TradeInfo]   function   first/r/n&quot;);<br>  return   NULL;<br>  }<br>  for(   int   i   =   0;   g_8583TradeDef[i].req.name   !=   NULL;   i   ++   )<br>  {<br>  if(   g_8583TradeDef[i].tcode   &amp;   tcode   )   return   &amp;g_8583TradeDef[i];<br>  }<br>  printf(&quot;   trade   not   find   !   /r/n&quot;);<br>  return   NULL;<br>  }   </p>
<p>  BOOL   Set8583TradeInfo(   TRADE_8583_DEF   *   pDef   )<br>  {<br>  g_8583TradeDef   =   NULL;<br>  for(   int   i   =   0   ;   pDef[i].req.name   !=   NULL   ;   i   ++   )<br>  {<br>  int   j;<br>  for(   j   =   0;   ;   j   ++   )<br>  {//保证所有的域都是声明了的<br>  int   index   =   pDef[i].req.bm[j];<br>  if(   index   >=   128   ||   index   \&lt;=   1   )   break;<br>  if(   !IsValidField(   index   )   )<br>  {<br>  printf(&quot;field[%d]   is   not   valid!/r/n&quot;,index);<br>  return   FALSE;<br>  }<br>  if(!(   Tbl8583[index-1].variable_flag   ==   0   ||<br>  Tbl8583[index-1].variable_flag   ==   1   ||<br>  Tbl8583[index-1].variable_flag   ==   2   ||<br>  Tbl8583[index-1].variable_flag   ==   3   )   )<br>  {<br>  printf(&quot;field[%d]   variable_flag   is   not   a   valid   number!/r/n&quot;,index);<br>  return   FALSE;<br>  }<br>  }<br>  }<br>  g_8583TradeDef   =   pDef;<br>  return   TRUE;<br>  }   </p>
<p>  Pack8583::Pack8583(   BOOL   bCompressInt   )<br>  {<br>  m_pTradeDef   =   NULL;<br>  m_bCompInt   =   bCompressInt;<br>  }   </p>
<p>  Pack8583::~Pack8583()<br>  {<br>  }   </p>
<p>  BOOL   Pack8583::Init(DWORD   tcode)<br>  {<br>  m_pTradeDef   =   Get8583TradeInfo(   tcode   );<br>  if(   m_pTradeDef   ==   NULL   )   return   FALSE;<br>  return   TRUE;<br>  }   </p>
<p>  BOOL   Pack8583::IsReqFieldValid(   int   field   )<br>  {<br>  for(   int   i   =   0   ;;   i   ++)<br>  {<br>  int   findex   =   m_pTradeDef->req.bm[i];<br>  if(   findex   \&lt;   0   ||   findex   >   128   )   break;<br>  if(   field   ==   findex   )   return   TRUE;<br>  }<br>  return   FALSE;<br>  }<br>  BOOL   Pack8583::IsAnsFieldValid(   int   field   )<br>  {<br>  for(   int   i   =   0   ;;   i   ++)<br>  {<br>  int   findex   =   m_pTradeDef->ans.bm[i];<br>  if(   findex   \&lt;   0   ||   findex   >   128   )   break;<br>  if(   field   ==   findex   )   return   TRUE;<br>  }<br>  return   FALSE;<br>  }<br>  BOOL   Pack8583::SetReqField(int   field,char*   buf,int   len)<br>  {<br>  if(   !IsReqFieldValid(   field)   )<br>  {<br>  printf(&quot;field   [%d]   is   not   valid!/r/n&quot;,field);<br>  return   FALSE;<br>  }   </p>
<p>  pair\&lt;   int,   PACK_8583_ITEM   >   item_insert;<br>  pair\&lt;   map\&lt;   int,   PACK_8583_ITEM   >::iterator,   BOOL   >   ret;   </p>
<p>  ISO8583_FIELD   &amp;F   =   Tbl8583[field-1];<br>  if(   F.variable_flag   ==   0   )<br>  {<br>  if(   len   !=   F.length   )<br>  {<br>  printf(&quot;field   [%d]   length   not   match!/r/n&quot;,field);<br>  return   FALSE;<br>  }<br>  }<br>  else<br>  {//1,2,3<br>  int   maxlen   =   0;<br>  if(   F.variable_flag   ==   1   )   maxlen   =   9;<br>  else   if(   F.variable_flag   ==   2   )   maxlen   =   99;<br>  else   if(   F.variable_flag   ==   3   )   maxlen   =   999;<br>  if(   len   >   maxlen   ||   len   \&lt;   0   )<br>  {<br>  printf(&quot;field   [%d]   data   length   out   of   range!/r/n&quot;,field);<br>  return   FALSE;<br>  }<br>  }   </p>
<p>  item_insert.first   =   field;<br>  ret   =   m_reqdata.insert(   item_insert   );<br>  PACK_8583_ITEM   &amp;item   =   ret.first->second;<br>  item.resize(   len   );<br>  memcpy(   &amp;item[0],   buf,   len   );<br>  return   TRUE;<br>  }<br>  PACK_8583_ITEM*   Pack8583::GetFromReq(   int   index   )<br>  {<br>  map\&lt;   int,   PACK_8583_ITEM   >   ::iterator   pos   =   m_reqdata.lower_bound(   index   );<br>  if(   pos   ==   m_reqdata.end()   ||   pos->first   !=   index   )   return   NULL;<br>  return   &amp;pos->second;<br>  }<br>  PACK_8583_ITEM*   Pack8583::GetFromAns(   int   index   )<br>  {<br>  map\&lt;   int,   PACK_8583_ITEM   >   ::iterator   pos   =   m_ansdata.lower_bound(   index   );<br>  if(   pos   ==   m_ansdata.end()   ||   pos->first   !=   index   )   return   NULL;<br>  return   &amp;pos->second;<br>  }   </p>
<p>  int   Pack8583::GetReqPackLen()<br>  {<br>  int   len   =   8;<br>  map\&lt;   int,   PACK_8583_ITEM   >::iterator   p;<br>  for(   p   =   m_reqdata.begin()   ;   p   !=   m_reqdata.end();   ++   p   )<br>  {<br>  int   findex   =   p->first;<br>  int   datalen   =   p->second.size();<br>  if(   m_bCompInt   &amp;&amp;   Tbl8583[findex-1].datatyp   ==   1   )<br>  {<br>  int   flen   =   Tbl8583[findex-1].variable_flag   +   datalen;<br>  len   +=   flen   /   2   +   flen   %   2;<br>  }<br>  else<br>  {<br>  len   +=   Tbl8583[findex-1].variable_flag;<br>  len   +=   datalen;<br>  }<br>  }<br>  if(   IsReqExtExist()   )   len   +=   8;<br>  return   len;<br>  }</p>
<p>C#的转换：</p>
<p>ASCII->string<br>Convert.ToInt32(ASCII);<br>Binary->string<br>Encoding.ASCII.GetString(Binary);</p>
<p>报文数据实例：</p>
<p>msgType：0200 30323030</p>
<p>1域:01110010 00111000 00000000 00010000 00110010 11000000 00010000 00001001</p>
<p>Bitmap:72 38 00 10 32 C0 10 09</p>
<p>2域:166224780001888456 313636323234373830303031383838343536</p>
<p>3域:000200 303030323030</p>
<p>4域:000000000001 303030303030303030303031</p>
<p>7域:0412103355 30343132313033333535</p>
<p>11域:000001 303030303031</p>
<p>12域:103355 313033333535</p>
<p>13域:0412 30343132</p>
<p>28域:C00000000 433030303030303030</p>
<p>35域:00 3030</p>
<p>36域:000 303030</p>
<p>41域:61006566 3631303036353636</p>
<p>42域: 860010030210013 383630303130303330323130303133</p>
<p>52 123456—06123456FFFFFFFF—C4F1029F060CA9B9—43344631303239463036304341394239</p>
<p>61域: 0186224780300001835 30313836323234373830333030303031383335</p>
<p>64域:4635BED3EC4B24C7</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-10-08T02:02:18.000Z"><a href="/2013/10/08/2013-04-22-f9ba07a0/">10月 8 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/10/08/2013-04-22-f9ba07a0/">VC中PCSC操作读卡器</a></h1>
  

    </header>
    <div class="entry">
      
        <p>1 引言</p>
<pre><code>完整的智能卡应用系统由后台服务程序、主机或终端应用程序和智能卡等组成，如图<span class="number">1</span>所示。其中，后台服务程序提供了支持智能卡的服务。例如，在一个电子付款系统中，后台服务程序可以提供到信用卡和帐户信息的访问；主机或终端应用程序一般存在于台式机或者终端、电子付款终端、手机或者一个安全子系统中，终端应用程序要处理用户、智能卡和后台服务程序之间的通讯；智能卡则存储用户的一些信息。

终端应用程序需要通过读卡器来访问智能卡，在一个系统中，通常存在多家厂商提供的读卡器，因此需要一个统一的读卡器设备驱动接口。

随着智能卡的广泛应用，为解决计算机与各种读卡器之间的互操作性问题，人们提出了PC<span class="regexp">/SC（Personal Computer/Smart Card）规范，PC/</span>SC规范作为读卡器和卡与计算机之间有一个标准接口，实现不同生产商的卡和读卡器之间的互操作性，其独立于设备的 API使得应用程序开发人员不必考虑当前实现形式和将来实现形式之间的差异，并避免了由于基本硬件改变而引起的应用程序变更，从而降低了软件开发成本。

Microsoft在其Platform SDK中实现了PC<span class="regexp">/SC，作为连接智能卡读卡器与计算机的一个标准模型，提供了独立于设备的 API，并与Windows平台集成。因此，我们可以用PC/</span>SC接口来访问智能卡。</code></pre>
<p>2 PC/SC概述</p>
<pre><code>PC/SC接口包含30多个以Scard为前缀的函数，所有函数的原型都在winscard.h中声明，应用程序需要包含winscard.lib，所有函数的正常返回值都是SCARD<span class="command">\_</span>S<span class="command">\_</span>SUCCESS。在这30多个函数中，常用的函数只有几个，与智能卡的访问流程（图2）对应，下面将详细介绍这些常用函数。</code></pre>
<p>3 PC/SC的使用</p>
<p>3.1建立资源管理器的上下文</p>
<pre><code>函数ScardEstablishContext()用于建立将在其中进行设备数据库操作的资源管理器上下文（范围）。

函数原型：LONG SCardEstablishContext(DWORD dwScope, LPCVOID pvReserved1, LPCVOID pvReserved2, LPSCARDCONTEXT phContext)<span class="comment">;</span>

各个参数的含义：</code></pre>
<p>（1）dwScope：输入类型；表示资源管理器上下文范围，取值为：SCARD_SCOPE_USER（在用户域中完成设备数据库操作）、SCARD_SCOPE_SYSTEM（在系统域中完成设备数据库操作）。要求应用程序具有相应的操作权限。</p>
<p>（2）pvReserved1：输入类型；保留，必须为NULL。</p>
<p>（3）pvReserved2：输入类型；保留，必须为NULL。</p>
<p>（4）phContext：输出类型；建立的资源管理器上下文的句柄。</p>
<p>下面是建立资源管理器上下文的代码：</p>
<pre><code><span class="title">SCARDCONTEXT</span>        hSC;

<span class="title">LONG</span>                          lReturn;

<span class="title">lReturn</span> = SCardEstablishContext(SCARD\_SCOPE\_USER, NULL, NULL, &amp;hSC);

<span class="title">if</span> ( lReturn!=SCARD\_S\_SUCCESS )

    printf(<span class="string">"Failed SCardEstablishContext\\n"</span>);</code></pre>
<p>3.2 获得系统中安装的读卡器列表</p>
<pre><code>函数ScardListReaders()可以列出系统中安装的读卡器的名字。

函数原型：LONG SCardListReaders(SCARDCONTEXT hContext, LPCTSTR mszGroups, LPTSTR mszReaders, LPDWORD pcchReaders)<span class="comment">;</span>

各个参数的含义：</code></pre>
<p>（1）hContext：输入类型；ScardEstablishContext()建立的资源管理器上下文的句柄，不能为NULL。</p>
<p>（2）mszGroups：输入类型；读卡器组名，为NULL时，表示列出所有读卡器。</p>
<p>（3）mszReaders：输出类型；系统中安装的读卡器的名字，各个名字之间用’\0’分隔，最后一个名字后面为两个连续的’\0’。</p>
<p>（4）pcchReaders：输入输出类型；mszReaders的长度。</p>
<pre><code>系统中可能安装多个读卡器，因此，需要保存各个读卡器的名字，以便以后与需要的读卡器建立连接。

下面是获得系统中安装的读卡器列表的代码：

<span class="keyword">char</span>               mszReaders[<span class="number">1024</span>];

LPTSTR               pReader, pReaderName[<span class="number">2</span>];

DWORD               dwLen=<span class="keyword">sizeof</span>(mzsReaders);

<span class="keyword">int</span>                         nReaders=<span class="number">0</span>;

lReturn = SCardListReaders(hSC, <span class="literal">NULL</span>, (LPTSTR)mszReaders, &amp;dwLen);

<span class="keyword">if</span> ( lReturn==SCARD\_S\_SUCCESS )

{

    pReader = (LPTSTR)pmszReaders;

    <span class="keyword">while</span> (\*pReader !=<span class="string">'\\0'</span> )

    {

        <span class="keyword">if</span> ( nReaders\&lt;<span class="number">2</span> ) <span class="comment">//使用系统中前2个读卡器</span>

            pReaderName[nReaders++]=pReader;

        printf(<span class="string">"Reader: %S\\n"</span>, pReader );

        <span class="comment">//下一个读卡器名</span>

        pReader = pReader + strlen(pReader) + <span class="number">1</span>;

    }

}</code></pre>
<p>3.3 与读卡器（智能卡）连接</p>
<pre><code>函数ScardConnect()在应用程序与读卡器上的智能卡之间建立一个连接。

函数原型：LONG SCardConnect(SCARDCONTEXT hContext, LPCTSTR szReader, DWORD dwShareMode, DWORD dwPreferredProtocols, LPSCARDHANDLE phCard, LPDWORD pdwActiveProtocol)<span class="comment">;</span>

各个参数的含义：</code></pre>
<p>（1）hContext：输入类型；ScardEstablishContext()建立的资源管理器上下文的句柄。</p>
<p>（2）szReader：输入类型；包含智能卡的读卡器名称（读卡器名称由ScardListReaders()给出）。</p>
<p>（3）dwShareMode：输入类型；应用程序对智能卡的操作方式，SCARD_SHARE_SHARED（多个应用共享同一个智能卡）、SCARD_SHARE_EXCLUSIVE（应用独占智能卡）、SCARD_SHARE_DIRECT（应用将智能卡作为私有用途，直接操纵智能卡，不允许其它应用访问智能卡）。</p>
<p>（4）dwPreferredProtocols：输入类型；连接使用的协议，SCARD_PROTOCOL_T0（使用T=0协议）、SCARD_PROTOCOL_T1（使用T=1协议）。</p>
<p>（5）phCard：输出类型；与智能卡连接的句柄。</p>
<p>（6）PdwActiveProtocol：输出类型；实际使用的协议。</p>
<pre><code>下面是与智能卡建立连接的代码：</code></pre>
<p>SCARDHANDLE          hCardHandle[2];</p>
<p>DWORD               dwAP;</p>
<p>lReturn = SCardConnect( hContext, pReaderName[0],    SCARD_SHARE_SHARED,</p>
<p>SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1, &amp;hCardHandle[0], &amp;dwAP );</p>
<p>if ( lReturn!=SCARD_S_SUCCESS )</p>
<p>{</p>
<pre><code><span class="function"><span class="title">printf</span><span class="params">(<span class="string">"Failed SCardConnect\\n"</span>)</span>;

<span class="title">exit</span><span class="params">(<span class="number">1</span>)</span>;</code></pre>
<p>}</p>
<p>与智能卡建立连接后，就可以向智能卡发送指令，与其交换数据了。</p>
<p>3.4 向智能卡发送指令</p>
<pre><code>函数ScardTransmit()向智能卡发送指令，并接受返回的数据。

函数原型：LONG SCardTransmit(SCARDHANDLE hCard, LPCSCARD<span class="command">\_</span>I0<span class="command">\_</span>REQUEST pioSendPci, LPCBYTE pbSendBuffer, DWORD cbSendLength, LPSCARD<span class="command">\_</span>IO<span class="command">\_</span>REQUEST pioRecvPci, LPBYTE pbRecvBuffer, LPDWORD pcbRecvLength);

各个参数的含义：</code></pre>
<p>（1）hCard：输入类型；与智能卡连接的句柄。</p>
<p>（2）pioSendPci：输入类型；指令的协议头结构的指针，由SCARD_IO_REQUEST结构定义。后面是使用的协议的协议控制信息。一般使用系统定义的结构，SCARD_PCI_T0（T=0协议）、SCARD_PCI_T1（T=1协议）、SCARD_PCI_RAW（原始协议）。</p>
<p>（3）pbSendBuffer：输入类型；要发送到智能卡的数据的指针。</p>
<p>（4）cbSendLength：输入类型；pbSendBuffer的字节数目。</p>
<p>（5）pioRecvPci：输入输出类型；指令协议头结构的指针，后面是使用的协议的协议控制信息，如果不返回协议控制信息，可以为NULL。</p>
<p>（6）pbRecvBuffer：输入输出类型；从智能卡返回的数据的指针。</p>
<p>（7）pcbRecvLength：输入输出类型；pbRecvBuffer的大小和实际大小。</p>
<pre><code>对于<span class="literal">T</span>=<span class="number">0</span>协议，收发缓冲的用法如下：</code></pre>
<p>（a）向智能卡发送数据：</p>
<pre><code>要向智能卡发送n<span class="command">\&gt;</span>0字节数据时，pbSendBuffer前4字节分别为T=0的CLA、INS、P1、P2，第5字节是n，随后是n字节的数据；cbSendLength值为n+5（4字节头+1字节Lc+n字节数据）。PbRecvBuffer将接收SW1、SW2状态码；pcbRecvLength值在调用时至少为2，返回后为2。</code></pre>
<p>BYTE             recvBuffer[260];</p>
<p>int                  sendSize, recvSize;</p>
<p>BTYE             sw1, sw2;</p>
<p>BYTE    select_mf[]={0xC0, 0xA4, 0x00, 0x00, 0x02, 0x3F, 0x00};</p>
<p>sendSize=7;</p>
<p>recvSize=sizeof(recvBuffer);</p>
<p>lReturn = SCardTransmit(hCardHandle[0], SCARD_PCI_T0, select_mf, sendSize,</p>
<p>NULL, recvBuffer, &amp;recvSize);</p>
<p>if ( lReturn != SCARD_S_SUCCESS )</p>
<p>{</p>
<pre><code><span class="function"><span class="title">printf</span><span class="params">(<span class="string">"Failed SCardTransmit\\n"</span>)</span>;

<span class="title">exit</span><span class="params">(<span class="number">1</span>)</span>;</code></pre>
<p>}</p>
<p>//返回的数据，recvSize=2</p>
<p>sw1=recvBuffer[recvSize-2];</p>
<p>sw2=recvBuffer[recvSize-1];</p>
<p>（b）从智能卡接收数据：</p>
<pre><code>为从智能卡接收n<span class="command">\&gt;</span>0字节数据，pbSendBuffer前4字节分别为T=0的CLA、INS、P1、P2，第5字节是n（即Le），如果从智能卡接收256字节，则第5字节为0；cbSendLength值为5（4字节头+1字节Le）。PbRecvBuffer将接收智能卡返回的n字节，随后是SW1、SW2状态码；pcbRecvLength的值在调用时至少为 n+2，返回后为n+2。</code></pre>
<p>BYTE          get_challenge[]={0x00, 0x84, 0x00, 0x00, 0x08};</p>
<p>sendSize=5;</p>
<p>recvSize=sizeof(recvBuffer);</p>
<p>lReturn = SCardTransmit(hCardHandle[0], SCARD_PCI_T0, get_challenge,</p>
<p>sendSize, NULL, recvBuffer, &amp;recvSize);</p>
<p>if ( lReturn != SCARD_S_SUCCESS )</p>
<p>{</p>
<pre><code><span class="function"><span class="title">printf</span><span class="params">(<span class="string">"Failed SCardTransmit\\n"</span>)</span>;

<span class="title">exit</span><span class="params">(<span class="number">1</span>)</span>;</code></pre>
<p>}</p>
<p>//返回的数据, recvSize=10</p>
<p>sw1=recvBuffer[recvSize-2];</p>
<p>sw2=recvBuffer[recvSize-1];</p>
<p>//data=recvBuffer[0]——recvBuffer[7]</p>
<p>（c）向智能卡发送没有数据交换的命令：</p>
<pre><code>应用程序既不向智能卡发送数据，也不从智能卡接收数据，pbSendBuffer前<span class="number">4</span>字节分别为<span class="literal">T</span>=<span class="number">0</span>的CLA、INS、P1、P2，不发送P3；cbSendLength值必须为<span class="number">4</span>。PbRecvBuffer从智能卡接收SW1、SW2状态码；pcbRecvLength值在调用时至少为<span class="number">2</span>，返回后为<span class="number">2</span>。</code></pre>
<p>BYTE    set_flag[]={0x80, 0xFE, 0x00, 0x00};</p>
<p>sendSize=4;</p>
<p>recvSize=sizeof(recvBuffer);</p>
<p>lReturn = SCardTransmit(hCardHandle[0], SCARD_PCI_T0, set_flag, sendSize,</p>
<p>NULL, recvBuffer, &amp;recvSize);</p>
<p>if ( lReturn != SCARD_S_SUCCESS )</p>
<p>{</p>
<pre><code><span class="function"><span class="title">printf</span><span class="params">(<span class="string">"Failed SCardTransmit\\n"</span>)</span>;

<span class="title">exit</span><span class="params">(<span class="number">1</span>)</span>;</code></pre>
<p>}</p>
<p>//返回的数据，recvSize=2</p>
<p>sw1=recvBuffer[recvSize-2];</p>
<p>sw2=recvBuffer[recvSize-1];</p>
<p>（d）向智能卡发送具有双向数据交换的命令：</p>
<pre><code><span class="literal">T</span>=<span class="number">0</span>协议中，应用程序不能同时向智能卡发送数据，并从智能卡接收数据，即发送到智能卡的指令中，不能同时有Lc和Le。

这只能分两步实现：向智能卡发送数据，接收智能卡返回的状态码，其中，SW2是智能卡将要返回的数据字节数目；从智能卡接收数据（指令为<span class="number">0x00</span>、<span class="number">0xC0</span>、<span class="number">0x00</span>、<span class="number">0x00</span>、Le）。</code></pre>
<p>BYTE      get_response={0x00, 0xc0, 0x00, 0x00, 0x00};</p>
<p>BYTE    internal_auth[]={0x00, 0x88, 0x00, 0x00, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};</p>
<p>sendSize=13;</p>
<p>recvSize=sizeof(recvBuffer);</p>
<p>lReturn = SCardTransmit(hCardHandle[0], SCARD_PCI_T0, internal_auth,</p>
<p>sendSize, NULL, recvBuffer, &amp;recvSize);</p>
<p>if ( lReturn != SCARD_S_SUCCESS )</p>
<p>{</p>
<pre><code><span class="function"><span class="title">printf</span><span class="params">(<span class="string">"Failed SCardTransmit\\n"</span>)</span>;

<span class="title">exit</span><span class="params">(<span class="number">1</span>)</span>;</code></pre>
<p>}</p>
<p>//返回的数据，recvSize=2</p>
<p>sw1=recvBuffer[recvSize-2];</p>
<p>sw2=recvBuffer[recvSize-1];</p>
<pre><code>   <span class="title">if</span> ( sw1!=0x61 )</code></pre>
<p>{</p>
<pre><code><span class="function"><span class="title">printf</span><span class="params">(<span class="string">"Failed Command\\n"</span>)</span>;

<span class="title">exit</span><span class="params">(<span class="number">1</span>)</span>;</code></pre>
<p>}</p>
<p>get_response[4]=sw2;</p>
<p>sendSize=5;</p>
<p>recvSize=sizeof(recvBuffer);</p>
<p>lReturn = SCardTransmit(hCardHandle[0], SCARD_PCI_T0, get_response,</p>
<p>sendSize, NULL, recvBuffer, &amp;recvSize);</p>
<p>if ( lReturn != SCARD_S_SUCCESS )</p>
<p>{</p>
<pre><code><span class="function"><span class="title">printf</span><span class="params">(<span class="string">"Failed SCardTransmit\\n"</span>)</span>;

<span class="title">exit</span><span class="params">(<span class="number">1</span>)</span>;</code></pre>
<p>}</p>
<p>//返回的数据，recvSize=10</p>
<p>sw1=recvBuffer[recvSize-2];</p>
<p>sw2=recvBuffer[recvSize-1];</p>
<p>//data=recvBuffer[0]——recvBuffer[7]</p>
<p>3.5 断开与读卡器（智能卡）的连接</p>
<pre><code>在与智能卡的数据交换完成后，可以使用函数ScardDisconnect()终止应用与智能卡之间的连接。

函数原型：LONG SCardDisconnect(SCARDHANDLE hCard, DWORD dwDisposition)<span class="comment">;</span>

各个参数的含义：</code></pre>
<p>（1）hCard：输入类型；与智能卡连接的句柄。</p>
<p>（2）dwDisposition：输入类型；断开连接时，对智能卡的操作，SCARD_LEAVE_CARD（不做任何操作）、SCARD_RESET_CARD（复位智能卡）、SCARD_UNPOWER_CARD（给智能卡掉电）、SCARD_EJECT_CARD（弹出智能卡）。</p>
<pre><code>下面是断开与智能卡连接的代码：</code></pre>
<p>lReturn = SCardDisconnect(hCardHandle[0], SCARD_LEAVE_CARD);</p>
<p>if ( lReturn != SCARD_S_SUCCESS )</p>
<p>{</p>
<pre><code><span class="function"><span class="title">printf</span><span class="params">(<span class="string">"Failed SCardDisconnect\\n"</span>)</span>;

<span class="title">exit</span><span class="params">(<span class="number">1</span>)</span>;</code></pre>
<p>}</p>
<p>3.6 释放资源管理上下文</p>
<pre><code>   在应用程序终止前时，应该调用函数ScardReleaseContext()释放资源管理器的上下文。

函数原型：LONG SCardReleaseContext(SCARDCONTEXT hContext)<span class="comment">;</span>

各个参数含义：</code></pre>
<p>（1）hContext：输入类型；ScardEstablishContext()建立的资源管理器上下文的句柄，不能为NULL。</p>
<p>下面是释放资源管理上下文的代码：</p>
<p>lReturn = SCardReleaseContext(hSC);</p>
<p>if ( lReturn!=SCARD_S_SUCCESS )</p>
<p>printf(&quot;Failed SCardReleaseContext\n&quot;);</p>
<p>4 小结</p>
<pre><code>以上介绍的通过PC/SC来操作智能卡的流程，可以封装在一个类中。例如，我们可以设计一个类:</code></pre>
<p>class CSmartReader</p>
<p>{</p>
<p>private:</p>
<pre><code><span class="title">SCARDCONTEXT</span> hSC;

<span class="title">LONG</span>                   lReturn;

<span class="title">char</span>               mszReaders[<span class="number">1024</span>];

<span class="title">LPTSTR</span>               pReader, pReaderName[<span class="number">2</span>];

<span class="title">DWORD</span>               dwLen;

<span class="title">int</span>                         nReaders, nCurrentReader;

<span class="title">SCARDHANDLE</span>          hCardHandle[<span class="number">2</span>];

<span class="title">DWORD</span>               dwAP;</code></pre>
<p>public:</p>
<pre><code>   CSmartReader(); <span class="comment">//建立上下文、取读卡器列表</span>

   \~CSmartReader(); <span class="comment">//释放上下文</span>

   <span class="keyword">void</span> SetCurrentReader(<span class="keyword">int</span> currentReader);

   <span class="keyword">int</span> GetReaders(); <span class="comment">//获得读卡器数目</span>

   <span class="keyword">int</span> ConnectReader(); <span class="comment">//与当前读卡器建立连接</span>

   <span class="keyword">int</span> DisConnectReader(); <span class="comment">//与当前读卡器断开连接</span>

   <span class="keyword">int</span> SendCommand(BYTE command[], <span class="keyword">int</span> commandLength, BYTE result[], <span class="keyword">int</span> \*resultLength); <span class="comment">//向读卡器发送命令，并接收返回的数据。返回值为sw</span></code></pre>
<p>};</p>
<pre><code>   这样，我们就可以方便地使用PC/SC接口了。</code></pre>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-10-08T02:02:18.000Z"><a href="/2013/10/08/2013-04-17-e783d9cf/">10月 8 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/10/08/2013-04-17-e783d9cf/">人生真是寂寞如雪</a></h1>
  

    </header>
    <div class="entry">
      
        <p>出自《温瑞安》的小说，貌似是神州奇侠之后有个网游小说人物的口头禅是这个，便给流行了。   </p>
<p>喻意就是： 人生就是美丽与短暂的组合，就像雪花一样，没有人能託在掌心细细欣赏，因为很快就融化了，人生就是如此的匆匆，还没等你回眸细细看清楚，自己已是百年身。（形容光阴飞奔，匆匆多年擦身而过，已然世事全非，百年只是藉用，也可解为垂暮）   </p>
<p>那种感受更是无人能够理解，而理解的人相对都已离（逝）去，所以活着就没人能懂身旁的人都离去的寂寞，只有无尽的等待自己也离去的那一天。 </p>
<p>如同雪花，天气放晴之时，默默融化在阳光下。</p>
<p>寂寞孤独什么的大概就是这个样子吧。 </p>
<p>这个样子是什么样子。 </p>
<p>有这样一个人。 </p>
<p>在你想找人陪你吃饭时会出现在你身边。 </p>
<p>在你长途旅行的途中会陪你发短信。 </p>
<p>在你晚上睡不著的时候会陪你聊天。 </p>
<p>在你心情不好的时候会逗你开心。 </p>
<p>在你不知道买哪件东西时会帮你做决定。 </p>
<p>在你哭泣的时候会递给你一张纸巾。 </p>
<p>在你无助的时候会给你支持和鼓励。 </p>
<p>在你没有方向的时候会为你亮一盏灯。   </p>
<p>但是总有一天生命走至某一处时就会是剩下一个人寂寞孤独。</p>
<p>陪你哭，陪你笑，陪你欢笑的人都一一为自己的生命走出你的世界‧而终就至最后就是孤独寂寞相伴。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-10-08T02:02:18.000Z"><a href="/2013/10/08/2013-04-17-b808af17/">10月 8 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/10/08/2013-04-17-b808af17/">Keil MDK编译器警告和错误详解</a></h1>
  

    </header>
    <div class="entry">
      
        <p>1.warning: #550-D: variable “d” was set but never used</p>
<p>描述:变量‘d’定义但从未使用,或者是,虽然这个变量你使用了,但编译器认为变量d所在的语句没有意义,编译器把它优化了.</p>
<p>解决:仔细衡量所定义的变量d是否有用,若是认定变量d所在语句有意义,那么尝试用volatile关键字修饰变量d,若是真的没有用,那么删除掉以释放可能的内存.</p>
<p>2.warning: #1-D: last line of file ends without a newline</p>
<p>描述:文件最后一行不是新的一行.编译器要求程序文件的最后一行必须是空行,想了半天没想通为什么要这样.</p>
<p>解决:可以不理会.若是觉得出现警告不爽,那么在出现警告的文件的最后一行敲个回车,空出一行.</p>
<p>​3. warning: #111-D: statement is unreachable</p>
<p>描述:声明不可能到达.多出现在这种场合:</p>
<p>int main(void)</p>
<p>{</p>
<p>…</p>
<p>while(1) //无限循环,这在不使用操作系统的程序中最常见</p>
<p>{</p>
<p>…</p>
<p>}</p>
<p>return 0; //这句声明在正常情况下不可能执行到,编译器发出警告</p>
<p>}</p>
<p>解决:不理会.</p>
<p>​4. warning: C3017W: data may be used before being set</p>
<p>描述:变量‘data’在使用前没有明确的赋值.如:</p>
<p>uint8 i,data; //定义变量i和data,二者都没有明确赋值</p>
<p>for ( i = 0; i \&lt; 8; i++) //变量‘i’在语句中被赋值0</p>
<p>{</p>
<p>if ( IO1PIN &amp; SO_CC2420 )</p>
<p>data |= 0x01; //变量‘data’在使用前没有明确赋值,编译器发出警告</p>
<p>else</p>
<p>data &amp;= ~0x01;</p>
<p>}</p>
<p>解决:应仔细衡量该变量的初始值是否为0，若是,可以不理会这个警告,因为MDK编译器在程序执行前,会将使用到的数据区初始化为0,但若是该变量的初始值不应该是0，忽略这个警告可能会引起致命错误.这个警告应引起足够重视.应养成变量赋初值的习惯,好在有编译器给把关.</p>
<p>​5. warning: #177-D: variable “temp” was declared but never referenced</p>
<p>描述:变量‘temp’进行了声明但没有引用.多出现在声明了一个变量,但却没有使用它,它和warning: #550-D: variable “temp” was set but never used不同之处在于temp从没有使用过.</p>
<p>解决:若是定义的变量确实没有用,删除掉;若是有用,则在程序中使用.</p>
<p>与该警告类似的还有 warning: #177-D: function “MACProcessBeacon” was declared but never referenced</p>
<p>​6. warning: #940-D: missing return statement at end of non-void function “DealwithInspect2”</p>
<p>描述:返回非空的函数“DealwithInspect2”的最后缺少返回值声明.如:</p>
<p>int DealwithInspect2(uint32 test)</p>
<p>{</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>//此处应该是return x;返回一个int型数据,若是没有返回值,编译器产生警告</p>
<p>}</p>
<p>7..warning: #1295-D: Deprecated declaration lcd_init - give arg types</p>
<p>描述:在定义函数的时候,如果你写上函数参数,就会有这个警告,比如void timer_init(); 这里就没有形参,如果这样的话,编译器会给出警告.</p>
<p>​1. error: #65: expected a “;”</p>
<p>描述:缺少分号.大多是漏忘‘;’.</p>
<p>解决:双击错误行,在定位到错误点的附近找到没加‘;’号的语句,加上分号.并不一定在定位到的错误行才却分号,可能是这行的上一行,也可能是下一行.</p>
<p>​2. error: #65: expected a “;”和 error: #20: identifier “xxxx” is undefined一块出现,而且后面的error: #20错误可能一大堆</p>
<p>描述:这个错误对于第一次遇上的人来说绝对是个噩梦,当错误出现,满怀希望的双击错误提示,来到错误行时却愕然发现,错误行绝对没有错,于是找找错误行的上一行,下一行,没有错误,再找上上行,下下行…让人无比郁闷的事情出现了:编译提示的所有错误行都不可能有错误出现.其实这最可能是你在.h文件声明外部变量或者函数时,没有在声明语句的最后加分号!如果你有很多模块,如main.c,lcd.c,key.c…有很多头文件,如lcd.h,key.h,若是在lcd.h文件声明函数时没有加分号,那么这种错误可能定为到main.c中,所以要检查所有头文件.</p>
<p>解决:仔细检查.h文件,将分号补上.</p>
<p>​3. Error: L6200E: Symbol flagu multiply defined (by uart0.o and main.o).</p>
<p>描述:变量(也是一种符号)flagu多处定义(在uart0.c中和main.c都定义了).通常错在全局变量定义重复.比如:在main.c中定义全局变量flagu:</p>
<p>uint8 flagu=0;</p>
<p>在uart0.c中也用到该变量,于是声明此变量,我通常都是先复制定义的变量再在变量前面加关键字extern修饰:</p>
<p>extern uint8 flagu=0;</p>
<p>然后编译,就会出现上面的连接错误,原因在于,我在uart0.c中是又定义了一个变量,而不是声明变量,因为我给变量赋了初值“flagu=0”,这样就重复定义了变量flag.正确的声明方法是去掉赋值部分:</p>
<p>extern uint8 flagu;</p>
<p>解决办法:找到重复定义的变量,看情况修改一处.</p>
<p>4.error: #159: declaration is incompatible with previous &quot;wr_lcd&quot; (declared at line 40)</p>
<p>描述:在wr_lcd函数还没有声明之前就已经使用了.多出现在两种情况:第一种,wr_lcd函数体还没有写,就已经用到了它,这种情况多出现在写一个程序的大体结构中,只是简单写一下框架.第二种情况比较常见,函数a调用函数b,但函数b的函数体在函数a的下面:</p>
<p>void a(void) //函数a的实体</p>
<p>{</p>
<p>b(); //调用函数b</p>
<p>}</p>
<p>void b(void) //函数b的实体</p>
<p>{</p>
<p>…</p>
<p>}</p>
<p>这样如果点编译,就会产生error: #159的错误,因为当函数a调用函数b时,发现在这之前都没有函数b的任何声明.</p>
<p>解决方法:在函数a调用函数b之前,对函数b进行声明,如:</p>
<p>void b(void); //对函数b进行声明</p>
<p>void a(void) //函数a的实体</p>
<p>{</p>
<p>b(); //调用函数b</p>
<p>}</p>
<p>void b(void) //函数b的实体</p>
<p>{</p>
<p>…</p>
<p>}</p>
<p>​5. error: #137: expression must be a modifiable lvalue</p>
<p>描述:表达式必须是一个可以修改的左值.主要出现在这种现象:</p>
<p>a=NUM;</p>
<p>NUM是一个数值或表达式,a为一个变量,但a被定义为像const这种不可更改的类型,导致NUM不能赋值给变量a.</p>
<p>解决方法:要么放弃赋值,要么修改变量属性.</p>
<p>6.error: #18: expected a “)”</p>
<p>如果是出现在c文件中, 多半是因为少了一个“)”,或者错误行有编译器不识别的字符</p>
<p>如果出现在头文件中,错误行又是一个函数声明,多半是因为在函数声明中有编译器不认识的字符</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-10-08T02:02:18.000Z"><a href="/2013/10/08/2013-04-17-14847bcb/">10月 8 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/10/08/2013-04-17-14847bcb/">那些年 其实我们都不懂沈佳宜</a></h1>
  

    </header>
    <div class="entry">
      
        <p><img src="https://writingsio.s3.amazonaws.com/attachments/516e38b94017a4298d0004c1/cc8d8b85c0c1dead8c42d71d49a6176a/0.jpg" alt=""><br>毕业典礼过后，闺蜜胡佳玮对沈佳宜说：“真羡慕你，从国中到高中，都有那么多男生追你。”沈佳宜答：“被那么多人喜欢是很好，但是……”她没有说出这个但是。 </p>
<p>而那一刻她的脸上，其实有着落寞的神情。<br>一个女生，有很多男生追，如果还说自己不开心很受困扰，<br>无疑会被其他女生嫉妒死，有得了便宜还卖乖的嫌疑。</p>
<p>所以她只是说：“不，我觉得自己是一个很幸福的人。”<br>确实很幸福，少年时的喜欢是学生时代最清新纯粹的一笔。 </p>
<p>但旁人不知道的是，这个世界上最还不起的是情债，这么多，她还不起。 </p>
<p>其实也知道，这些男生对自己的喜欢只不过是当时情绪，甚至只是盲目跟风而已。<br>分别之后，他们会喜欢上别的女生，一如当初喜欢过自己。<br>是何等相通的小女生心情。</p>
<p>从男生的角度来说，喜欢就是要靠近，要拥有，喜欢了就去追，<br>不去想将来又何必要去想将来。简简单单，直截了当。<br>但女生会想很多，会想在一起距离拉近之后，你看到我的缺点，就不会那么喜欢我了，<br>那份感情就变了，还不如保留一份距离，给你我最好的模样。<br>这就是女孩的成熟，也是她的自卑与怯懦。 </p>
<p>当所有人都以为她是意气风发的好学生，以为她是高傲矜持的乖乖女，<br>她其实已经在喜欢的人面前低下头去，低下去，低到尘埃里去，只用矜持来伪装自己。<br> 柯景腾以为他已经够主动够勇敢，但他恰恰缺一点，<br>那就是他与沈佳宜的心理年龄差，注定了他不懂沈佳宜。 </p>
<p>那时候沈佳宜对柯景腾说：“你真的喜欢我吗？我觉得你喜欢的是你想象中的我。”<br>柯景腾说：“我没那么会想象。”<br>看这段对话的时候我在心里笑了，也痛了。 </p>
<p>他不知道她在想什么，不知道她为什么这么说。<br>我觉得沈佳宜是对的，成熟的女生应该会寻求比她更成熟的男生的保护，<br>可是却偏偏对幼稚的男生动了心。<br>她应该也很困扰与为难，不知道该怎么办。 </p>
<p>（我就是幼稚才会追你那么久）应该是这一句<br>我一直想，如果她的身边还有一个高大帅气成熟沉稳的男生存在，<br>她喜欢上柯景腾的几率应该会很小很小。<br>她明显是喜欢成熟的人的，<br>这从她日后选择跟她比较有共同语言的阿和以及成熟的丈夫就可以看出。 </p>
<p>喜欢与动心可能是被感动，不是真的爱，否则怎么会忍心错过。 </p>
<p>他幼稚地办一场格斗赛想要表现自己，<br>却不知道这样对自己的不爱惜，只能破灭女孩的依赖感。<br>幼稚的男生或许可爱，或许会逗女生笑，但是他不能带来安全感，而这恰恰是最要命的一点。 </p>
<p>朋友看完电影后都说：“他们没有在一起好可惜”<br>问我：“你觉得呢？”<br>我说：“不会，我觉得这是他们最好的结局。”其实也是最现实的结局。 </p>
<p>沈佳宜成功了保持了这份距离，她促使柯景腾发奋，改变了一个男孩的命运轨迹。<br>于是柯景腾在05年化身九把刀用她的名字写了一部小说，在11年又把它搬上大银幕，让全世界都知道了沈佳宜。<br>这就是结局，这才是结局。 </p>
<p>现实中的柯景腾和沈佳宜不是帅哥美女，<br>现实中的柯景腾和沈佳宜都已人至中年，<br>然后让无数个柯景腾和沈佳宜们在他们的故事里找寻共鸣，回忆过去 </p>
<p>之前和一个表姐聊起来的时候她说：“每一届基本上都会有那么几个沈佳宜。”<br>我说：“每个地域每个时代都有沈佳宜。”<br>多得是幼稚的柯景腾，多得是优秀的沈佳宜。<br>但少的是勇敢去追去表白的柯景腾，少的是会喜欢上你的幼稚的沈佳宜。 </p>
<p>现实生活中，好学生与坏学生的差距；<br>是第一排到最后一排的距离；<br>是同窗期间说话不超过十句、是不敢表白没有交集、是思想的鸿沟与差距。<br>所以只会在毕业即将分离的时候才选择表明心意，<br>哪怕她以前从未注意过你，你也觉得她不可能会喜欢上你。 </p>
<p>两个世界的人，很难交汇，这是真的。<br>哪怕在一起终究也会因为价值观差异而分开。<br>所以错过，也是宿命。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-10-08T02:02:18.000Z"><a href="/2013/10/08/2013-04-17-11262e74/">10月 8 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/10/08/2013-04-17-11262e74/">不够优秀就不要腆着脸继续占便宜</a></h1>
  

    </header>
    <div class="entry">
      
        <p>“一个人事业上的成功，只有15%是由于他的专业技术，另外的85%要依靠人际关系、处世技巧。”或许正是在戴尔·卡耐基这句名言的指引下，很多人都把人脉积累作为自己职业生涯规划实施过程中的重要一步。但是，哪些人更容易积累有效的、为你所用的人脉？凭什么别人就甘愿为你所用？你是否把自己的成功过于依赖在人际关系的构建上，而忘记了自身能力的积累？如果没有思考清楚这些问题，而盲目崇拜人际关系，可能只会陷入本末倒置的境地。</p>
<p>有一次在北大讲座，遇到一位学生问我，“老师，你说学习重要，还是经营人脉重要？”看着他一脸大杂烩的表情，我先拿出本子记下了这个问题，然后告诉他说，这是个比较大的话题，我会仔细写篇文章放在网上的，然后给了他我的博客地址。而后又补了一句，“相信我，所谓的人脉就算重要，也根本没他们说的那么重要”。<br>让我们细说从头。先动脑思考一下，你愿意与什么样的人成为朋友？从幼儿园开始，每个人就都已经有一些选择朋友的原则——尽管并不自知。事实上，资源分布的不均匀，必然造成人与人之间的某种依附关系。观察一下，就可以看到事实：幼儿园里玩具多的孩子更容易被其他孩子当作朋友。那么，玩具最多的孩子朋友最多么？答案并非肯定。<br>如果你像我一样有机会、也恰好愿意多花一点心思与那个玩具最多的孩子交谈的话，你也很快就会发现，在他的心目中，与所有成年人一样，朋友被划分为“真正的朋友”和“一般的朋友”。以下我们姑且把那个玩具最多的孩子叫做“小强”。<br>当时我很好奇。耐心等待小强告诉我谁是他“真正的朋友”。最终，他告诉我，真正的朋友只有两个。其中一个是男孩，另外一个是女孩。那我就问他，“为什么你认为那男孩是你真正的朋友？”小强一秒钟都没犹豫，告诉我说，“他从来都不抢我的玩具，他跟我换。”我又问他，“那，为什么你认为那女孩是你真正的朋友？” 这次小强犹豫了好一阵子，在确定我会给他保密之后，磕磕巴巴地说，“她好看。我把新玩具全都先给她……”我笑。过一会儿又问他，“她觉得你好看么？”小强愣了一下，满眼的无辜，“不知道……”我又问，“那她现在手里的玩具是谁的？”小强突然显得很紧张，“不是我的。”我决定不去问那小女孩什么问题了。<br>基于种种原因，生活中总是只有少数人是大多数人想要结交的朋友。但是同样基于种种原因，大多数人并不知道那些少数的人是如何理解他们大多数人的行为的。刚才小强说他那个“真正的朋友”从来都不“抢”他的玩具，而是“换”。注意这两个词。<br>在这里我们不讨论所谓的“心计”。确实有些人有很深的城府，至少比另外一些人更深，他们可以用常人想不出的，就算想得出来也做不到的手段达到自己的目的。在这里，我们只讨论最普遍的情况。<br>所有的人都喜欢并重视甚至偏爱一种交换，“公平交换”。小强也许并没有意识到，他所拥有的玩具数量，使得他从概率角度出发很难遇到“公平交换”，因为绝大多数孩子没有多少玩具，甚至干脆没有玩具，所以，那些孩子实际上没有机会，也没有能力与他进行“公平交换”。对他来讲，不公平的交换，等同于“抢”，没有人喜欢“被抢”。而与他“换”的那个男孩，让小强感受到公平。小强也有自己想要的但是却不拥有的，所以，他也去“换”而不会去“抢，”因为他自己就不喜欢 “被抢”——把最新的玩具都给那女孩先玩……<br>某种意义上，尽管绝大多数人不愿意承认，他们的所谓“友谊”实际上只不过是“交换关系”。可是，如果自己拥有的资源不够多不够好，那么就更可能变成“索取方”，做不到“公平交换”，最终成为对方的负担。这样的时候，所谓的“友谊”就会慢慢无疾而终。也有持续下去的时候，但更可能是另外一方在耐心等待下一次交换，以便实现“公平”。电影《教父》里，棺材铺的老板亚美利哥·勃纳瑟拉决心找教父考利昂替他出气并为自己的女儿讨回公道的时候，亚美利哥就是“索取方”。许多年后，教父考利昂终于在一个深夜敲开了亚美利哥的门……<br>所以，可以想象，资源多的人更喜欢，也更可能，与另外一个资源数量同样多或者资源质量对等的人进行交换。因为，在这种情况下，“公平交易”更容易产生。事实上，生活里随处可见这样的例子。哪怕在校园里，“交换”本质没有体现的那么明显，但是，同样性质的行为并不鲜见。比如，某系公认的才子，会与另外一个系里公认的另外一个才子会“机缘巧合”地邂逅而后成为“死党”。俗话常说，“英雄所见略同”，可能就是他们一见如故的原因，所以，他们之间的谈话以及任何其他活动往往都会让他们觉得相互非常“投机”。<br>这样的例子太多太多。<br>当15岁的沈南鹏和14岁的梁建章第一次相识时，这两个懵懂少年不会意识到17年后他俩会联手创造一个中国互联网产业的奇迹。在1982年第一届全国中学生计算机竞赛上，这两个数学“神童”同时获奖。<br>不是因为他们两个要好，才各自变得优秀。而是因为他们各自都很优秀，才可能非常要好，而后命运的碰撞产生绚丽的火花。<br>而反过来，这些被公认为优秀的人，事实上往往并不“低调”，也并不“平易近人”。这并不是他们故意的。他们无意去惹恼身边那些在他们看来“平庸”的人，只不过无形中他们有这样的体会——“与这些人交流，沟通成本太高……”除非有一天，这些人终于意识到自己应该保护自己，因为有些误解根本没机会解释。于是，他们开始“谦虚”，他们学会“低调”，他们显得“平易近人”。<br>好多年前，我注意到一个现象，当别人求助于我的时候，我内心往往非常抵触，却又怕别人说我是所谓的“不够意思的人”，于是硬着头皮去做自己不喜欢做的事情。有一次特别受伤的时候，突然一闪念，想明白，原来这种尴尬本质上并不是来自于我没有“乐于助人”的品性，而是来自于我自己的精力并不足够旺盛，没有旺盛到处理自己的事情绰绰有余的同时，还有大把的时间精力用来帮别人做事——事实上，我自己根本已经是正在过河的泥菩萨。后来，我开始怀疑，雷锋的领导是否太白痴，因为他没有给自己的下属分配足够的工作。——这是那天晚上与我来讲非常惊喜的一件事儿，因为我发现我正在独立思考。<br>承认自己能力有限，是心理健康的前提。从我重新思考雷锋的领导那天开始，我挣扎着去学习如何做事量力而行。说起来好笑，自己的智商有限到过去竟然没想到“量力而行”是如此高难度的行为模式——1)承认自己能力有限；2)不怕在别人面前露怯；3)敢于不去证明自己是“好人”……<br>所以说，往往只有优秀的人才拥有有效的人脉。并且正因为这些人随时随地都可能要回避“不公平交换”的企图，他们才更加注重自身的质量，知道不给他人制造麻烦，独善其身是美德。常言说，“事多故人离”，是非常准确的观察。而那些不优秀的人往往并不知道这样貌似简单的道理，他们甚至没有意识到自己的状况只能使得自己扮演“索取者”的角色；进而把自己的每一次“交换”都变成“不公平交换”，最终更可能使交换落空——因为谁都不喜欢“不公平交换”；每次交换的落空，都进一步造成自己的损失，使得自己拥有的资源不是数量减少，就是质量下降，进一步使自己更可能沦为“索取者”——恶性循环，甚至可能永世不得翻身。<br>还有些人，过分急于建立所谓的人脉，并全然不顾自己的情况究竟如何。对于这样的人，人们常用一些专门的词来描述他们，“谄媚”、“巴结”、“欺下媚上”、甚至“结党营私”等等。这样的人，往往也不是他们故意非要如此的。他们只是朦胧地意识到自己一个人的力量过于渺小，所以，才希望能够借助其他的力量。而一个人越是渺小，越是衬得他的欲望无比强烈。这样的人特征非常明显，其中一个就是，在日常生活中他们经常有意无意地用亲密的方式提及大家仰望的人物，无论他们与“大人物”是否真的存在私交密往。在中文语境里，他们就会只说名字不说姓氏：李开复不叫“李开复”，在他们嘴里是“开复”；李彦宏不叫“李彦宏”在他们嘴里是“彦宏”，沈南鹏不叫“沈南鹏”，在他们嘴里就是“南鹏”；最近我听到更恐怖、更另人毛发悚立的是，“小俞”（俞敏洪），“小邓”（邓峰），“大想”（理想）……<br>整体上来看，人脉当然很重要。不过，针对某个个体来说的话，更重要的是他所拥有的资源。有些资源很难瞬间获得，比如金钱、地位、名誉，尤其在这些资源的获得更多地依赖出身和运气的现实世界里。然而有些资源却可以很容易从零开始，比如一个人的才华与学识。才华也好学识也罢，是可以通过努力必然获得的东西。一个人心智能力一旦正常开启，就会发现自己在这个信息唾手可得的世界里，只要正常地努力，并且有耐心和时间做朋友，很容易成为至少一个领域的专家。努力并不像传说中的那么艰苦，只不过是“每天至少专心学习工作六个小时”；耐心却远比大多数人想象得巨大，“要与时间相伴短则至少五年，长则二十年”。<br>许多年后的今天，我又发现另外一个多年前智商平平的我不可能想明白或者预想到的事情（当然我现在也依然智商平平，只是多了些智慧）：当一个人身边都是优秀的人的时候，没有人求他帮忙——因为身边这些优秀的人几乎无一例外都以耽误别人的时间为耻，同时，这些人恰好是因为遇到问题能够解决问题才被认为是优秀的。<br>如果，终于有一天，你已经成为某个领域的专家，你会惊喜于真正意义上的有价值的所谓高效的人脉居然会破门而入。你所遇到的人将来自完全不同的层面，来自各种各样意想不到的不同的方向。而你自己也不再是过去一无是处的你，你不再是“索取者”，你扮演的是“乐于助人”的角色——很少有人讨厌善意的帮助，更何况你是被找来提供帮助的呢。<br>甚至，你会获得意外的帮助。如果你是一个优秀的人、有价值的人，那么就会有很多另外优秀的人、有价值的人为你提供帮助。这样的时候，这样的帮助往往确实是 “无私”的。正如没有哪个医生做到救死扶伤之后仅仅因为酬劳太少而恼羞成怒的一样，那些品质优秀到一定地步，境界豁达到一定层次的人，往往真的可以做到 “施恩不图报”。因为对他们来讲，能够有机会“验证自己的想法”本身就已经比什么都重要，并且可以令他们身心愉悦。然而真正有趣的现象是，被帮助的你也正因为并非寻常之辈，所以一定懂得“滴水之恩，当以涌泉相报”的道理。最终皆大欢喜，只因为“沟通成本几近于零”，同时的效果自然是“交流收益相对无穷放大”。良性循环。<br>生活的智慧就在于，集中精力改变那些能够改变的，而把那些不能改变的暂时忽略掉。专心打造自己，把自己打造成一个优秀的人，一个有用的人，一个独立的人，比什么都重要。打造自己，就等于打造人脉——如果人脉真的像他们说的那么重要的话。事实上，我总觉得关于人脉导致成功的传说其实非常虚幻，只不过是不明真相的人只好臆造出来的幻象罢了。<br>我并不是说，从此就不用关心自己身边的任何人了，或者说从此就无需与任何人打交道了。善于与人交往也是一种需要学习，并且也需要耗费大量时间实践的技能。我只是提醒你，别高估自己，误以为自己有那么多足够的时间可以妥善地处理好你与你身边所有人的关系。浏览一下你的手机通讯簿里的名字吧，有多少已经很久没有联系过了？这么多年，我只见过两三个人回答我说，“最长时间没联系的，也不超过两个星期。”其中一个还是特别固执而特殊的人，他的手机通讯簿里，总计才有 22个名字。<br>事实上，真正的关心最终只有一个表现：为之心甘情愿地花费时间，哪怕“浪费”时间。这也很容易理解。因为，当你把时间花费到一个人身上的时候，相当于在他的身上倾注了你生命的一段——哪管最终的结果如何，反正，那个人那件事都成了你生命中的一部分，不管最后你喜欢还是不喜欢。每个人的时间都是有限的。所以最终，“真正的好朋友”谁都只有几个而已。<br>这实在是一个大到写两本书都可以的话题。以下是我的几个简单的，但实践起来并不是那么容易的建议：<br>专心做可以提升自己的事情，学习并拥有更多更好的技能，成为一个值得交往的人；<br>学会独善其身，以不给他人制造麻烦为美德；用你的独立赢得尊重；<br>除非有特殊原因，应该尽量回避那些连在物质生活上都不能独善其身的人；那些精神生活上都不能独善其身的，就更应该回避了——尽管甄别起来比较困难；<br>真正关心一个朋友的意思是说，你情愿在他身上花费甚至浪费更多的时间；<br>记住，一个人的幸福程度，往往取决于他多大程度上可以脱离对外部世界的依附。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-10-08T02:02:18.000Z"><a href="/2013/10/08/2013-04-17-9c503ed6/">10月 8 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/10/08/2013-04-17-9c503ed6/">为什么明明是喜剧，却会流泪</a></h1>
  

    </header>
    <div class="entry">
      
        <p>这个世界上还有一个故事，叫做《大话西游》。<br>世界是巨大的枷锁，你不得不重复自己或是别人的生活。<br>记得长辈说过：年轻是一种罪过。他们说我们不成熟。<br>真切地为自己的不俗喝彩，在深切的郁闷中，突然就看懂了《大话西游》的开头： 一位才华横溢又无法无天的青年（孙悟空），根本不喜欢世人摊派给他的大事业（西天取经）。他尤其受不了师父（唐僧）的唠唠叨叨，可世俗条规（观音）又不放过他。为让他悔悟，心甘情愿地去取经，唐僧和观音达成妥协：让他五百年后重新做人。 这真是一个宿命的开始。<br>九七一师兄曰：“大学的孩子都是玻璃罐里养蛤蟆，前途光明出路不大。”再贴切不过。大闹天宫无非是大学四年的黄金时光罢了，找到工作走上社会任你盖世的才华浑身的个性也自有翻不出的五指山来压。只有戴上紧箍咒取经去，九九八十一难，做一个奇奇怪怪的佛。你别无选择。<br>五百年后的悟空叫至尊宝，在五岳山从事一份很有前途的职业—— 山贼。命运却要他扮演孙悟空，至尊宝只是个过渡罢了。蜘蛛精来了，白骨精来了，菩提老祖来了，牛魔王也来了……都是棋子，安静地立在命棋盘的中央。<br><img src="http://www.timetimetime.net/upload/201303302008027131.jpg" alt="">他的路线是早定好的：（1）一个人给他三颗痣（2）戴上紧箍咒（3）打败牛魔王（4）西天取经。可怜的至尊宝什么都不知道，认认真真做山贼，还爱上了白骨精，想和她结为百年之好。<br>所有的事都瞒着他接二连三地发生。<br>十年前我绝对不知道今天自己会在杭州的一所大学里学习，如今已隐隐感受到那冥冥之中的牵引。可怕的是这还绝不是终点，不到游戏结束我不会知道答案。真相将揭晓，在我临死的瞬间，给至尊宝三颗痣的人是紫霞仙子。谁说的：总有一个女孩出现，让男孩最终成为男人。而男人永远都不可能得到她，那简直是一定的。<br>非常喜欢紫霞的开场白：“现在我郑重宣布，这座山上所有的东西都是我的，包括你。”那样的气贯云霄，像一个童话故事。<br>而现实是：这个世界没有什么属于你，包括你自己。也许我们就是为了创造属于自己的东西才来到这个世上，因为年轻，所以押注于爱情。<br>至尊宝拒绝了紫霞，他以为自己还爱晶晶。见到晶晶，他又发现紫霞才是真爱。命运一直在同他开玩笑：至尊宝忽然成了孙悟空，千辛万苦找晶晶又爱上了紫霞。而抉择是那样残酷：要打败牛魔王救紫霞，就必须戴上紧箍咒做回神通广大的孙悟空；而戴上紧箍咒就不能有半点情欲，只有取经去。<br>为至尊宝不平：不明白在这样的故事里为何爱情总要成为牺牲品，干嘛不让周星弛携紫霞纤纤小手——走先！我曾无数次在网上反映过类似意见，搞得很累。爱情是那样美丽而脆弱，无法直面生活的琐碎和坚韧。哪段感情又没有绚烂的瞬间和艰难的长久，在一起就会幸福吗，未必。<br>至尊宝挖开自己的心，看到了紫霞留在那里的一滴眼泪，毕竟曾经沧海过。 五百年又五百年，兜了一个大圈子又回到了原地。人没能战胜命运，而人的尊严却在抗争中得到了肯定，人的情感也必将不朽。 “生亦何欢，死亦何苦。”大彻大悟。<br>紧箍咒，圈住昔日的梦想，圈住棱角分明的个性。<br>成熟是一个很痛的词，它不一定会得到，却一定会失去。<br>永别了，激情四溢的花样年华！永别了，神采飞扬的青春岁月！永别了，同学！永别了，爱人同志！至此后漫漫长路我独行。<br>望着荧幕上扛着金箍棒的悟空，忽地明白了本班男生什么自称光棍。向光棍行者们敬礼！<br>全片最后一句台词是：“你看那个人，好奇怪哟，象一条狗。”<br>罗曼蒂克、海誓山盟、生死相许……面对爱情这些都是琐碎，不值一提。<br>爱情就是爱情，不是别的什么东西。<br>能与爱情同在的只有生命，其他都滚一边儿去。<br>你爱了，难道还不够吗？<br>悟空爱了，不论晶晶还是紫霞，他都要将爱情进行到底。<br>晶晶爱了，那个弃她而去的悟空，“不能和喜欢的人在一起，做人又怎会开心。”<br>紫霞爱了，“谁拔出我的紫青宝剑，谁就是我的如意郎君。”<br>爱一个人需要理由吗？<br>孙悟空会爱白骨精，*八戒爱上了蜘蛛精。紫霞爱他至深，因为他拔出了一把剑。<br>故事里的人找爱人的理由永远千奇百怪：王子要用水晶鞋才能找到灰姑娘，薛宝钗要那有玉的人来配……可生活永远现实得多，芸芸众生，谁又能许谁一个未来，自欺欺人罢了。<br>有理由也好，没理由也罢，可还是要爱。让我去，过程就是结果，无悔。<br>爱无须掩饰无须矫做无须患得患失，只要像紫霞一样说：“让我们立刻开始这段感情吧！先亲我一下。”<br>爱是身不由己。<br>晶晶口中道：“我再也不会为这个男人心痛了。”可还是要为他拔剑与人拼命。<br>至尊宝梦中也要叫紫霞的名字七百四十一次，不知道的人觉得紫霞一定欠了他很多钱。<br>紫霞说：“就象飞蛾，明知会受伤也要扑到火上。” “我无力抗拒，向你狂奔去。”无可救药的痴迷。<br>爱是奋不顾身。<br>至尊宝对晶晶说：“你杀了我吧，我不希望你看我的时候心里却想着别的人。”<br>晶晶以为：“都是骗我的。”跳下崖去。<br>紫霞把身体挡在至尊宝面前，刺进牛魔王的铁叉里。<br>一时间，以后的人生如何，大家都无所谓了。连那样宝贵的性命，也打算随时给爱情作了祭品。一个个一头扎进这情爱苦海，宁愿永生永世不得超生。<br>爱深刻莫测。<br>三十娘流着泪说：“想我春三十娘貌美如花，却跟这么丑的人有了。” 这是多少美丽自负的女子的宿命：心中的他是能文能武翩翩少年，枕边人却鼾声如雷大腹便便。谁敢说多年后眼望自己的丈夫不会有如此感觉，真不知幸福还是心酸。不过还是要为他挺身而去无限牺牲，像春三十娘为*八戒放下断龙石与牛魔王同归于尽。<br>晶晶爱悟空，至尊宝爱晶晶，紫霞爱至尊宝，“他爱你你爱我我爱他”，千古无解的方程。《白马啸西风》里说：“如果你深深爱着的人，却又深深爱上了别人，能有什么法子？”<br>所以紫霞说：“爱一个人原来是那么痛苦。” 晶晶找不到那个抛弃她的悟空（象不象殷离），告诉至尊宝：“你经过五百年回来要找的不是我。”至尊宝原以为可以与初恋共度今生，谁知初恋的时候并不懂情爱人生。当年被他推开的紫霞已经悄无声息地抵达他灵魂的最深处，而他却不自知。可紫霞死了：“我的意中人是个盖世英雄，有一天他会踩着七色的云彩来娶我，我猜中了前头，可是我猜不着这结局……”<br>没有人猜得中结局，一切随风而去。<br>恋爱的时候我们都不懂爱情，懂得爱情后却失去了可以相爱的时光。<br>最绝望不是他不爱你或他离你而去，最绝望是你忘记了怎么去爱一个人，你已丧失了爱的能力。<br>请记住下面的台词：“曾经有一份真诚的爱情摆在我的面前，但是我没有珍惜。等到了失去的时候才后悔莫及，尘世间最痛苦的事莫过于此。如果上天可以给我一个机会再来一次的话，我会对你说三个字“我爱你”。如果非要把这份爱加上一个期限，我希望是一万年！” 也顺便记住这段话的原版，在王家卫的《重庆森林》里：“如果记忆是一个罐头，我希望它永远都不会过期，如果一定要加上一个期限的话，我希望是一万年。”<br>至尊宝第一次说这番话是骗紫霞，第二次说已痛不欲生。 总有一天，你会在灵魂最温柔的一隅为她重复这段话，为了你们即将封存的一万年。 “如果有一天我忍不住问你，你一定要骗我。不管你心里有多么不愿意，你都不要告诉我你从来没有喜欢过我。” </p>
<p>此情可待成追忆，只是当时已惘然！（文/等待戈多）</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-10-08T02:02:18.000Z"><a href="/2013/10/08/2013-04-17-5da7a5bc/">10月 8 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/10/08/2013-04-17-5da7a5bc/">Keil sct</a></h1>
  

    </header>
    <div class="entry">
      
        <p>在keil中编译的程序通过了，但是debug的时候会出现一些错误： *** error 65: access violation at 0x4C000018 : no ‘write’ permission *** error 65: access violation at 0x00000000 : no ‘execute/read’ permission (ram.sct的时候) 我发现当我工程设置中linker中选择了runinram.sct和runinflash.sct或者自动生成的sct文件的时候就出现上面的错误。应该就是地址的问题。但是具体怎么修改才能解决这个错误，还没弄明白。弄明白了再发。   下面是找了一篇值得参考的文章： 原文地址： <a href="http://hi.baidu.com/pengjj0807/blog/item/ef73e287a212453cc65cc3be.html" target="_blank"><a href="http://hi.baidu.com/pengjj0807/blog/item/ef73e287a212453cc65cc3be.html">http://hi.baidu.com/pengjj0807/blog/item/ef73e287a212453cc65cc3be.html</a></a> KEIL下分散加载文件的使用 *************************************************************<br>; *** Scatter-Loading Description File generated by uVision ***<br>; ************************************************************* LR_IROM1 0x08000000 0x00004000 ; load region size_region 第一个加载域，起始地址0x08000000，{ 大小0x00004000 ER_IROM1 0x08000000 0x00004000 ; load address = execution address第一个运行时域， { 起始0x08000000，大小0x00004000 *.o (RESET, +First) IAP第一阶段还是在FLASH中运行<br>*(InRoot\$\$Sections)<br>startup_stm32f10x_md.o<br>}<br>ER_IROM2 0x20008000 0x00004000 ; load address = execution address第二个运行时域，<br> { 起始0x20008000，大小0x00004000 .ANY (+RO) IAP第二阶段加载到SDRAM中运行<br>}<br>RW_IRAM1 0x20000000 0x00008000 ; RW data 把可读写的数据和初始化为0的数据放在内存SDRAM的开头 { .ANY (+RW +ZI)<br>}<br>} 让MDK自己分配—选linker-usexxx</p>
<p>对于分散加载的概念，在《ARM体系结构与编程》书中第１１章有明确介绍。 分散加载文件（即scatter file　后缀为.scf）是一个文本文件，通过编写一个分散加载文件来指定<br>ARM连接器在生成映像文件时如何分配RO,RW,ZI等数据的存放地址。如果不用SCATTER文件指定，那么<br>ARM连接器会按照默认的方式来生成映像文件，一般情况下我们是不需要使用分散加载文件的。 但在某些场合，我们希望把某些数据放在指定的地址处，那么这时候SCATTER文件就发挥了非常大的作用<br>而且SCATTER文件用起来非常简单好用。 举个例子：比如像LPC2378芯片具有多个不连续的SRAM，通用的RAM是32KB，可是32KB不够用，我想把<br>某个.C中的RW数据放在USB的SRAM中，那么就可以通过SCATTER文件来完成这个功能。<br>下面是就这个例子作的说明：<br>这是一个标准的常用的分散加载文件，现在加注释于后，方便以后查阅：<br>;******************************************************************************<br>;<br>; SCATTER LOADING DEION<br>; ARM<br>; KEIL&#39;s uVision3<br>; (RealView Microprocessor Developer Kit)<br>;<br>; Filename : LPC2378_Flash.scat<br>;****************************************************************************** LR_IROM1 0x00000000 0x00080000 ;; 第一个加载域，名字为LR_IROM1，起始<br>{　　　　　　　　　　　　　　　　　 ;;地址为0x0，大小为0x80000<br>ER_IROM1 0x00000000 0x00080000 ;;加载域中的运行时域，名字为ER_IROM1<br>{ ;; 起始地址为0x0，大小为0x80000<br>vectors.o (VECT, +First) ;;将vectors.c编译后生成的文件vectors.o中的代码<br>init.o (INIT) ;;以及init.o中的代码<br>* (+RO) ;;以及所有编译生成的RO属性的代码全部存放在<br>} ;;运行时域ER_IROM1指定的地址范围内，存放方式：顺序存放 RW_IRAM1 0x40000000 0x0000e800　　;;这是第二个运行时域，功能同上<br>{ ;;其中　*是代表具有（）里面指定的属性的全部数据<br>*(+RW,+ZI) ;;与*功能相似的有.ANY,后面说明<br>} ;; The following declarations select the “two region model” ;<br>;; A default __user_initial_stackheap() will be used ;<br>ARM_LIB_HEAP 0x40007000 EMPTY 0x00000100 {} ;;指定堆栈地址<br>ARM_LIB_STACK 0x40008000 EMPTY -0x00000E00 {}<br>}<br>下面是针对LPC2378的USB　SRAM作数据RAM使用的配置： ;******************************************************************************<br>;<br>; SCATTER LOADING DEION<br>; ARM<br>; KEIL&#39;s uVision3<br>; (RealView Microprocessor Developer Kit)<br>;<br>; Filename : LPC2378_Flash.scat<br>;****************************************************************************** LR_IROM1 0x00000000 0x00080000 ;; 第一个加载域，名字为LR_IROM1，起始<br>{　　　　　　　　　　　　　　　　　 ;;地址为0x0，大小为0x80000<br>ER_IROM1 0x00000000 0x00080000 ;;加载域中的运行时域，名字为ER_IROM1<br>{ ;; 起始地址为0x0，大小为0x80000<br>vectors.o (VECT, +First)<br>init.o (INIT)<br>* (+RO)<br>} RW_IRAM1 0x40000000 0x0000e800<br>{<br>.ANY(+RW,+ZI)　　　　　;; 此处.ANY替换原来的*，是因为下面的一个执行域对指定的模块中的RW,ZI数据指定了存放地址<br>;;用.ANY就可以把已经被指定的具有RW,ZI属性的数据排除<br>} ;; The following declarations select the “two region model” ; 找了3个分散加载文件来分析： 1、7x256的flash.sct分散加载文件： Load_region 0x100000 0x40000 {//ro起始地址为0x100000，大小为0x40000<br>Fixed_region 0x100000 0x40000 {<br>*(cstartup +First)<br>.ANY (+RO)<br>}<br>Relocate_region 0x200000 {//rw和zi段的地址为0x200000 *.o (VECTOR, +First)<br>.ANY (+RW +ZI)<br>}<br>ARM_LIB_HEAP 0x20E000 EMPTY 0x1000 {<br>}<br>ARM_LIB_STACK 0x210000 EMPTY -0x1000 {<br>}<br>} 2、sram.sct文件 Load_region 0x200000 0x10000 {<br>Fixed_region 0x200000 {<br>*.o (VECTOR, +First)<br>.ANY (+RO)<br>}<br>Relocate_region +0 {<br>*(cstartup +First)<br>.ANY (+RW +ZI)<br>}<br>ScatterAssert((ImageLength(Fixed_region) + ImageLength(Relocate_region)) \&lt; 0xE000)<br>ARM_LIB_HEAP 0x20E000 EMPTY 0x1000 {<br>}<br>ARM_LIB_STACK 0x210000 EMPTY -0x1000 {<br>}<br>} 3、自定义的sram.sct LR_IROM1 0x00200000 0x00008000 { ; load region size_region<br>ER_IROM1 0x00200000 0x00008000 { ; load address = execution address//加载域等于运行域<br>*.o (RESET, +First)<br>*(InRoot\$\$Sections)<br>.ANY (+RO)<br>}<br>RW_IRAM1 0x00208000 UNINIT 0x00008000 { ; RW data//rw和zi段<br>.ANY (+RW +ZI)<br>}<br>} 什么是分散加载文件这里就不赘述了。 前面两个分散加载文件是从别的地方拷过来的，用在自己的程序中可能会有问题，因为如果不修改它的话它就固定了加载地址和运行地址，如果程序简单又比较小的话可能不会有问题，但是如果程序代码比较大，超出了那两个加载文件的定义大小可能就会出问题，解决办法也很简单，直接修改.sct文件直到适合你的代码。 更好的办法是自己定义一个分散加载文件，在keil中勾选Use Memory Layout from Target Dialog，那么加载文件就是从你定义irom和iram等地址得到的，如果不勾选的话就是通过你自己指定的加载文件来加载。 如果分散加载文件不对的话，可能出现的问题就是明明是在sram中调试程序，但是却能神奇的通过flash downloader下载到flash中去，刚开始也是不解，后来才发现是分散加载文件有错误，我使用了一个指定的flash.sct分散加载文件，这样的话我设置的irom和iram都无效了，编译器直接根据我指定的flash.sct来分布代码和加载代码，又查看了一下flash.sct文件是加代码加载到flash地址空间的，这就是为什么在jlink-sram工程中也能通过flash downloader工具烧写代码到flash中去的原因.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-10-08T02:02:18.000Z"><a href="/2013/10/08/2013-04-17-5cdb3f80/">10月 8 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/10/08/2013-04-17-5cdb3f80/">What Is Happiness</a></h1>
  

    </header>
    <div class="entry">
      
        <p>The idea of “happiness” to be sure, will not sit still for easy definition; the best one can do is to try to set some extremes to the idea and then work in toward the middle. </p>
<p>To think of happiness as acquisitive and competitive will do to set the materialistic extreme. </p>
<p>To think of it as the idea one senses in, say, a holy man of India will do to set the spiritual extreme.<br>That holy man’s idea of happiness is in needing nothing from outside himself.<br>In wanting nothing, he lacks nothing.<br>He sits immobile, rapt in contemplation, free even of his own body, or nearly free of it.<br>If devout admirers bring him food, he eats it; if not, he starves indifferently. Why be concerned?<br>What is physical is an illusion to him.<br>Contemplation is his joy and he achieves it through a fantastically demanding discipline, the accomplishment of which is itself a joy within him.</p>
<p>Is he a happy man?<br>Perhaps his happiness is only another sort of illusion. But who can take it from him?<br>And who will dare say it is more illusory than happiness on the installment plan?<br>But, perhaps because I am Western, I doubt such catatonic happiness, as I doubt the dreams of the happiness-market.<br>What is certain is that his way of happiness would be torture to almost any Western man.<br>Yet these extremes will still serve to frame the area within which all of us must find some sort of balance.<br>Thoreau – a creature of both Eastern and Western thought – had his one firm sense of that balance.<br>His aim was to save on the low levels in order to spend on the high.<br>Possession for its own sake or in competition with the rest of the neighborhood would have been Thoreau’s idea of the low levels. The active discipline of heightening one’s perception of what is enduring in nature would have been his idea of the high.<br>What he saved from the low was time and effort he could spend on the high. </p>
<p>Thoreau certainly disapproved of starvation, but he would put into feeding himself only as much effort as would keep him functioning for more important efforts.<br>Effort is the gist of it.<br>There is no happiness except as we take on life-engaging difficulties.<br>Short of the impossible, as Yeats put it, the satisfaction we get from a lifetime depend on how high we choose our difficulties.<br>Robert Frost was thinking in something like the same terms when he spoke of “The pleasure of taking pains”.<br>The mortal flaw in the advertised version of happiness is in the fact it purports to be effortless.<br>We demand difficulty even in our games.<br>We demand it because without difficulty there can be no game. A game is a way of making something hard for the fun of it.<br>The rules of the game are an arbitrary imposition of difficulty.<br>When the spoilsport ruins the fun, he always does so be refusing to play by the rules.<br>It is easier to win at chess if you are free, at your pleasure, to change the whole arbitrary rules, but the fun is in winning within the rules.<br>No difficulty, no fun.<br>The buyers and sellers at the happiness-market seem too often to have lost their sense of the pleasure of difficulty.<br>Heaven knows what they are playing, but it seems a dull game.<br>And the Indian holy man seems dull to us, I suppose, because he seems to be refusing to play anything at all.<br>The Western weakness may be in the illusion that happiness can be bought. Perhaps the Eastern weakness is in the idea that there is such a thing as perfect (and therefore static) happiness.<br>Happiness is never more than partial. There are no pure states of mankind.<br>Whatever else happiness may be, it is neither in having nor in being, but in becoming.<br>What the Founding Fathers declared for us as an inherent right, we should do well to remember, was not happiness but the pursuit of happiness.<br>What they might have underlined, could they have foreseen the happiness-market, is the cardinal fact that happiness is in the pursuit itself, in the meaningful pursuit of what is life engaging and life-revealing, which is to say, in the idea of becoming.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




<nav id="pagination">
  
    <a href="/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/3/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  

  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2013 NG
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>